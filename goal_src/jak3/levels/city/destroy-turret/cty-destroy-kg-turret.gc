;;-*-Lisp-*-
(in-package goal)

;; name: cty-destroy-kg-turret.gc
;; name in dgo: cty-destroy-kg-turret
;; dgos: LCTYTURRET

(declare-type kg-turbo-turret process-focusable)
(declare-type bombbot nav-enemy)

(define *city-destroy-turret-kg-squad-member-settings* (new 'static 'inline-array kg-squad-member-settings 4
                                                      (new 'static 'kg-squad-member-settings
                                                        :object-type (traffic-type roboguard)
                                                        :max-target-count #x7f
                                                        :enemy-type (traffic-type guard-a)
                                                        )
                                                      (new 'static 'kg-squad-member-settings
                                                        :object-type (traffic-type roboguard)
                                                        :max-target-count #x7f
                                                        :enemy-type (traffic-type guard-b)
                                                        )
                                                      (new 'static 'kg-squad-member-settings
                                                        :object-type (traffic-type flying-turret)
                                                        :max-target-count #x7f
                                                        :target-count 3
                                                        :enemy-type (traffic-type metalhead-grunt)
                                                        )
                                                      (new 'static 'kg-squad-member-settings
                                                        :object-type (traffic-type spydroid)
                                                        :max-target-count #x7f
                                                        :target-count 10
                                                        :enemy-type (traffic-type metalhead-flitter)
                                                        )
                                                      )
        )

(define *is-task-done?* #f)
(define *close-task?* #f)
(define *last-turret* (the string #f))
(define *last-turret-id* (the int32 0))

(defun find-last-turret ()
  (dotimes (s4-0 (-> *level* length))
    (let ((v1-8 (-> *level* level s4-0)))
        (when (= (-> v1-8 status) 'active)
          (let ((s3-0 (-> v1-8 bsp level entity)))
            (dotimes (s2-0 (-> s3-0 length))
            (let* ((s0-0 (-> s3-0 data s2-0 entity))
              (s1-0 (-> s0-0 extra trans))
              (proc (-> s0-0 extra process))
              (name (the string (-> proc name)))
              (id (res-lump-value s0-0 'extra-id int32 :default (the-as uint128 -1) :time -1000000000.0))
              )          
              (when (and proc (type-type? (-> proc type) kg-turbo-turret) (not (logtest? (-> s0-0 extra status) (entity-perm-status subtask-complete))))
                (set! *last-turret* name)
                (set! *last-turret-id* id)
                (format *stdcon* "last-turret: ~s~%" name)
                (format *stdcon* "last-turret-id: ~d~%" id)
                )
              )
            )
          )
        )
      )
    )
  (none)
  )

(deftype task-manager-city-destroy-turret (task-manager)
  ((manager-entity     entity-actor)
   (music-started?     symbol)
   (increase-count?    symbol)
   (turret-count       int32)
   (turret-max-count   int32)
   (minimap            connection-minimap)
   )
  (:methods
    (setup-alt-actor-entity-count! (_type_) none)
    )
  )

(defmethod taskman-event-handler ((this task-manager-city-destroy-turret) (arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (local-vars (v0-2 object))
  (case arg2
    (('start-music)
     (if (not (-> this music-started?))
         (set-setting! 'music 'citysnpr 0.0 0)
         )
     (set-setting! 'pilot #f 0.0 0)
     (send-event *target* 'end-mode 'pilot)
     (set-setting! 'airlock #f 0.0 0)
     (set! (-> this music-started?) #t)
     )
    (('turret-destroyed)
     (+! (-> this turret-count) -1)
     )
    (else
      ((method-of-type task-manager taskman-event-handler) this arg0 arg1 arg2 arg3)
      )
    )
  )

(defmethod setup-alt-actor-entity-count! ((this task-manager-city-destroy-turret))
  (local-vars (sv-16 res-tag))
  (let ((a0-2 (entity-by-name "destroy-turret-manager-1")))
    (when a0-2
      (set! (-> this manager-entity) (the-as entity-actor a0-2))
      (set! sv-16 (new 'static 'res-tag))
      (let ((v0-2 (res-lump-data a0-2 'alt-actor pointer :tag-ptr (& sv-16))))
        (cond
          ((and v0-2 (nonzero? (-> sv-16 elt-count)))
           (set! (-> this turret-max-count) (the-as int (-> sv-16 elt-count)))
           (format *stdcon* "turret-max-count: ~d~%" (-> this turret-max-count))
           (format *stdcon* "turret-count: ~d~%" (-> this turret-count))
           )
          (else
            (format *stdcon* "ERROR: ~s: entity missing alt-actor!~%" a0-2)
            )
          )
        )
      )
    )
  (cond
    ((and (< (-> this turret-count) (-> this turret-max-count)) (= (-> this increase-count?) #f))
      ;(when (-> this turret-count)
        ;(+! (-> this turret-count) 1)
        ;)
      (let ((entity (the-as entity-actor #f)))
        (dotimes (i (-> this turret-max-count))
          (set! entity (entity-actor-lookup (-> this manager-entity) 'alt-actor i))
          (when (and entity (not (logtest? (-> entity extra perm status) (entity-perm-status subtask-complete))))
            (+! (-> this turret-count) 1)
            )
          )
        )
      )
    ((>= (-> this turret-count) (-> this turret-max-count))
      (set! (-> this increase-count?) #t)
      )
    ((= (-> this turret-count) 1)
      (find-last-turret)
      )
    ((<= (-> this turret-count) 0)
      (set! *is-task-done?* #t)
      (talker-spawn-func (-> *talker-speech* 94) *entity-pool* (target-pos 0) (the-as region #f))
      (if *close-task?*
        (send-event this 'complete)
        )
      )
    )
  (none)
  )

(defmethod task-manager-method-26 ((this task-manager-city-destroy-turret))
  (cond
    ((not (task-closed? "city-destroy-kg-turrets-resolution"))
      (setup-alt-actor-entity-count! this)
      )
    )
  (none)
  )

(defmethod set-time-limit ((this task-manager-city-destroy-turret))
  (let ((t9-0 (method-of-type task-manager set-time-limit)))
    (t9-0 this)
    )
  (set-setting! 'city-sound '(citybbf) 0.0 2)
  (set! (-> this music-started?) #f)
  (set! (-> this increase-count?) #f)
  (set-setting! 'kg-enemy-settings #f 0.0 *city-destroy-turret-kg-squad-member-settings*)
  (set! (-> this manager-entity) #f)
  (set! (-> this turret-max-count) 0)
  (set! (-> this turret-count) 0)
  (set! *is-task-done?* #f)
  (set! *close-task?* #f)
  (none)
  )

(defstate complete (task-manager-city-destroy-turret)
  :virtual #t
  :enter (behavior ()
    (format 0 "task cleared!~%")
    )
  :code (behavior ()
    (set-time! (-> self state-time))
    (until (time-elapsed? (-> self state-time) (seconds 2))
      (suspend)
      )
    (task-close! "city-destroy-kg-turrets-resolution")
    )
  )

(defpartgroup group-cty-guard-turret-hit
  :id 186
  :duration (seconds 3)
  :linger-duration (seconds 1)
  :flags (sp0)
  :bounds (static-bspherem 0 0 0 15)
  :parts ((sp-item 1118 :period (seconds 5) :length (seconds 0.085) :offset -10)
    (sp-item 1119 :fade-after (meters 60) :period (seconds 5) :length (seconds 0.1))
    (sp-item 1120 :fade-after (meters 60) :falloff-to (meters 60) :period (seconds 5) :length (seconds 0.335))
    (sp-item 1121 :fade-after (meters 200) :falloff-to (meters 200) :period (seconds 5) :length (seconds 0.167))
    (sp-item 1122 :period (seconds 5) :length (seconds 0.017) :offset -10)
    (sp-item 1123 :fade-after (meters 150) :falloff-to (meters 150) :period (seconds 5) :length (seconds 0.167))
    )
  )

(defpart 1121
  :init-specs ((:texture (explosion-edge level-default-sprite))
    (:num 1.0 1.0)
    (:scale-x (meters 1) (meters 1))
    (:rot-z (degrees 0) (degrees 360) :store)
    (:scale-y (meters 0.8) (meters 0.2))
    (:r 255.0)
    (:g 255.0)
    (:b 255.0)
    (:a 32.0 32.0)
    (:vel-y (meters 0.02) (meters 0.01))
    (:scalevel-x (meters 0.01) (meters 0.13333334))
    (:scalevel-y :copy scalevel-x)
    (:fade-r 0.0)
    (:fade-g -0.36)
    (:fade-b -4.24)
    (:fade-a -0.22068965)
    (:friction 0.95)
    (:timer (seconds 3.335))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3))
    (:func 'sparticle-motion-blur)
    (:next-time (seconds 0.085) (seconds 0.015))
    (:next-launcher 1124)
    (:conerot-x '*sp-temp*)
    )
  )

(defpart 1123
  :init-specs ((:texture (explosion-nebula level-default-sprite))
    (:num 1.0 1.0)
    (:scale-x (meters 1) (meters 1))
    (:rot-z (degrees 0))
    (:scale-y :copy scale-x)
    (:r 255.0)
    (:g 255.0)
    (:b 255.0)
    (:a 0.0)
    (:vel-y (meters 0.02) (meters 0.01))
    (:scalevel-x (meters 0.01) (meters 0.13333334))
    (:rotvel-z (degrees -0.12) (degrees 0.24))
    (:scalevel-y :copy scalevel-x)
    (:fade-r 0.0)
    (:fade-g -0.36)
    (:fade-b -4.24)
    (:fade-a 0.22068965)
    (:friction 0.95)
    (:timer (seconds 3.335))
    (:flags (sp-cpuinfo-flag-2))
    (:next-time (seconds 0.085) (seconds 0.015))
    (:next-launcher 1124)
    (:conerot-x (degrees 0) (degrees 360))
    )
  )

(defpart 1124
  :init-specs ((:fade-r 0.0) (:fade-g 0.0) (:fade-b 0.0) (:next-time (seconds 0.017) (seconds 0.065)) (:next-launcher 1125))
  )

(defpart 1125
  :init-specs ((:scalevel-x (meters 0.016666668) (meters 0.016666668))
    (:scalevel-y :copy scalevel-x)
    (:fade-r -0.44)
    (:fade-g -2.36)
    (:fade-b -2.64)
    (:next-time (seconds 0.117) (seconds 0.047))
    (:next-launcher 1126)
    )
  )

(defpart 1126
  :init-specs ((:scalevel-x (meters 0.008333334) (meters 0.008333334))
    (:scalevel-y :copy scalevel-x)
    (:fade-r -1.2944444)
    (:fade-g -0.7111111)
    (:fade-b -0.094444446)
    (:fade-a -0.06545454 -0.06545454)
    (:next-time (seconds 0.5) (seconds 0.097))
    (:next-launcher 1127)
    )
  )

(defpart 1127
  :init-specs ((:fade-r 0.0) (:fade-g 0.0) (:fade-b 0.0))
  )

(defpart 1122
  :init-specs ((:texture (glow level-default-sprite))
    (:num 1.0)
    (:scale-x (meters 5))
    (:scale-y :copy scale-x)
    (:r 255.0)
    (:g 255.0)
    (:b 255.0)
    (:a 96.0)
    (:scalevel-x (meters 0.5))
    (:rotvel-z (degrees 0.3))
    (:scalevel-y :copy scalevel-x)
    (:fade-r 0.0)
    (:fade-g -1.28)
    (:fade-b -5.1)
    (:fade-a 0.0)
    (:timer (seconds 0.335))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3))
    (:next-time (seconds 0.167))
    (:next-launcher 1128)
    )
  )

(defpart 1128
  :init-specs ((:scalevel-x (meters -0.2))
    (:scalevel-y :copy scalevel-x)
    (:fade-r 0.0)
    (:fade-g -2.56)
    (:fade-b 0.0)
    (:fade-a -1.92)
    )
  )

(defpart 1120
  :init-specs ((:texture (specs level-default-sprite))
    (:num 5.0 3.0)
    (:x (meters 0.25))
    (:scale-x (meters 1) (meters 0.25))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 255.0)
    (:g 255.0)
    (:b 255.0)
    (:a 16.0 48.0)
    (:vel-y (meters 0.083333336) (meters 0.083333336))
    (:scalevel-x (meters 0.006666667) (meters 0.0016666667))
    (:rotvel-z (degrees -0.12) (degrees 0.24))
    (:scalevel-y :copy scalevel-x)
    (:fade-r 0.0)
    (:fade-g -0.18)
    (:fade-b -2.12)
    (:accel-y (meters -0.00016666666) (meters -0.00033333333))
    (:friction 0.87)
    (:timer (seconds 3.335))
    (:flags (sp-cpuinfo-flag-2))
    (:next-time (seconds 0.117) (seconds 0.047))
    (:next-launcher 1129)
    (:conerot-x (degrees 0) (degrees 360))
    )
  )

(defpart 1129
  :init-specs ((:scalevel-x (meters 0.0016666667))
    (:scalevel-y :copy scalevel-x)
    (:fade-r 0.0)
    (:fade-g 0.02)
    (:fade-b 0.23555556)
    (:next-time (seconds 0.15) (seconds 0.047))
    (:next-launcher 1130)
    )
  )

(defpart 1130
  :init-specs ((:fade-r -0.5543478) (:fade-g -0.5543478) (:fade-a -0.13913043))
  )

(defpart 1118
  :init-specs ((:texture (bigpuff level-default-sprite))
    (:num 3.0 1.0)
    (:x (meters 0) (meters 0.6))
    (:scale-x (meters 2) (meters 1.5))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 70.0 20.0)
    (:g 70.0 20.0)
    (:b 70.0 20.0)
    (:a 0.0 40.0)
    (:vel-y (meters 0) (meters 0.1))
    (:scalevel-x (meters 0.033333335) (meters 0.016666668))
    (:rotvel-z (degrees -0.12) (degrees 0.24))
    (:scalevel-y :copy scalevel-x)
    (:fade-r 3.3)
    (:fade-g 3.12)
    (:fade-b 1.18)
    (:fade-a 1.76)
    (:friction 0.88)
    (:timer (seconds 2.367))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3))
    (:next-time (seconds 0.117) (seconds 0.047))
    (:next-launcher 1131)
    (:conerot-x (degrees 0) (degrees 360))
    (:conerot-y (degrees 0) (degrees 360))
    )
  )

(defpart 1131
  :init-specs ((:scalevel-x (meters 0.0033333334))
    (:scalevel-y :copy scalevel-x)
    (:fade-r -0.53333336)
    (:fade-g -1.9666667)
    (:fade-b -2.2)
    (:fade-a -0.41666666)
    (:next-time (seconds 0.15) (seconds 0.047))
    (:next-launcher 1132)
    )
  )

(defpart 1132
  :init-specs ((:scalevel-x (meters 0))
    (:scalevel-y :copy scalevel-x)
    (:fade-r -0.38833332)
    (:fade-g -0.21333334)
    (:fade-b -0.028333334)
    (:fade-a -0.38833332)
    )
  )

(defpart 1119
  :init-specs ((:texture (motion-blur-part level-default-sprite))
    (:num 4.0 2.0)
    (:scale-x (meters 0.1) (meters 0.25))
    (:rot-x 4)
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y (meters 0.2) (meters 0.1))
    (:r 128.0 128.0)
    (:g 96.0)
    (:b 64.0)
    (:a 64.0 64.0)
    (:scalevel-x (meters 0.13333334) (meters 0.02))
    (:fade-g 1.6)
    (:fade-b 3.2)
    (:fade-a -1.6)
    (:timer (seconds 0.267))
    (:flags (sp-cpuinfo-flag-2))
    )
  )

(deftype kg-turbo-turret (process-focusable)
  ((incoming-attack-id  uint32)
   (jm-turret           joint-mod)
   (jm-gunsL            joint-mod)
   (jm-gunsR            joint-mod)
   (angle-turret        degrees)
   (angle-guns          degrees)
   (last-no-zero        int64)
   (next-time-shot      time-frame)
   (num-shots           uint32)
   (focus               focus  :inline)
   (id                  int32)
   (destroyed           symbol)
   (hit-points          int32)
   (minimap             connection-minimap)
   (trigger-distance    meters)
   )
  (:state-methods
    idle
    hostile
    explode
    moribund
    )
  (:methods
    (kg-turbo-turret-method-32 (_type_) none)
    (kg-turbo-turret-method-33 (_type_) none)
    (kg-turbo-turret-method-34 (_type_) none)
    (kg-turbo-turret-method-35 (_type_) quaternion)
    )
  )

(defskelgroup skel-cty-guard-turret cty-guard-turret cty-guard-turret-lod0-jg cty-guard-turret-idle-ja
              ((cty-guard-turret-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 7.5)
              )

(defskelgroup skel-cty-guard-turret-explode cty-guard-turret cty-guard-turret-explode-lod0-jg cty-guard-turret-explode-idle-ja
              ((cty-guard-turret-explode-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 15)
              )

(define *kg-turbo-turret-exploder-params*
  (new 'static 'joint-exploder-static-params
    :joints (new 'static 'boxed-array :type joint-exploder-static-joint-params
      (new 'static 'joint-exploder-static-joint-params :joint-index 3 :parent-joint-index 8)
      (new 'static 'joint-exploder-static-joint-params :joint-index 4 :parent-joint-index 8)
      (new 'static 'joint-exploder-static-joint-params :joint-index 5 :parent-joint-index 6)
      (new 'static 'joint-exploder-static-joint-params :joint-index 6 :parent-joint-index 6)
      (new 'static 'joint-exploder-static-joint-params :joint-index 7 :parent-joint-index 6)
      (new 'static 'joint-exploder-static-joint-params :joint-index 8 :parent-joint-index 7)
      (new 'static 'joint-exploder-static-joint-params :joint-index 9 :parent-joint-index 6)
      )
    :collide-spec #x1
    )
  )

(defbehavior kg-turbo-turret-event-handler kg-turbo-turret ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('attack)
     (when (and (-> self next-state) (= (-> self next-state name) 'hostile))
       (let ((a0-1 (get-penetrate-using-from-attack-event (the-as process-drawable arg0) arg3))
             (v1-5 (the-as object (-> arg3 param 1)))
             )
         (when (!= (-> (the-as attack-info v1-5) id) (-> self incoming-attack-id))
           (set! (-> self incoming-attack-id) (-> (the-as attack-info v1-5) id))
           (cond
             ((logtest? (penetrate
                          flop
                          punch
                          spin
                          uppercut
                          mech-punch
                          mech-bonk
                          dark-punch
                          dark-bomb
                          explode
                          jak-red-shot
                          jak-dark-shot
                          enemy-dark-shot
                          )
                        a0-1
                        )
              (+! (-> self hit-points) -10)
              )
             ((logtest? (attack-mask damage) (-> (the-as attack-info v1-5) mask))
              (set! (-> self hit-points) (- (-> self hit-points) (the int (-> (the-as attack-info v1-5) damage))))
              )
             (else
               (set! (-> self hit-points) (- (-> self hit-points) (penetrate-using->damage a0-1)))
               )
             )
           (when (< (-> self hit-points) 0)
             (sound-play "gturret-explode")
             (go-virtual explode)
             )
           )
         )
       )
     )
    (('track)
     (if (and (-> self next-state) (= (-> self next-state name) 'hostile))
         #t
         #f
         )
     )
    )
  )

(defmethod get-trans ((this kg-turbo-turret) (arg0 int))
  "@returns the `trans` [[vector]] from the process's `root` (typically either a [[trsqv]] or a [[collide-shape]])"
  (let ((v1-0 (-> this root)))
    (cond
      ((= arg0 3)
       (let ((v0-0 (vector<-cspace! (new 'static 'vector) (-> this node-list data 6))))
         (set! (-> v0-0 w) (-> this root root-prim prim-core world-sphere w))
         v0-0
         )
       )
      (else
        (-> v1-0 trans)
        )
      )
    )
  )

(defmethod get-inv-mass ((this kg-turbo-turret))
  0.01
  )

(defstate idle (kg-turbo-turret)
  :virtual #t
  :event kg-turbo-turret-event-handler
  :enter (behavior ()
    (focus-on! (-> self focus) *target*)
    (ja-channel-push! 1 0)
    (ja-no-eval :group! cty-guard-turret-idle-ja :num! zero)
    (transform-post)
    (logior! (-> self focus-status) (focus-status ignore))
    )
  :exit (behavior ()
    (logclear! (-> self focus-status) (focus-status ignore))
    (let ((a1-0 (new 'stack-no-clear 'event-message-block)))
      (set! (-> a1-0 from) (process->ppointer self))
      (set! (-> a1-0 num-params) 0)
      (set! (-> a1-0 message) 'start-music)
      (let ((t9-0 send-event-function)
            (v1-4 (-> *game-info* sub-task-list (game-task-node city-destroy-kg-turrets-resolution)))
            )
        (t9-0
          (handle->process (if (-> v1-4 manager)
                               (-> v1-4 manager manager)
                               (the-as handle #f)
                               )
                           )
          a1-0
          )
        )
      )
    )
  :code sleep-code
  :post (behavior ()
    (let ((gp-2 (handle->process (-> self focus handle))))
      (when (and gp-2
                 (and *traffic-engine*
                      (let ((f0-0 (vector-vector-xz-distance-squared (get-trans (the-as process-focusable gp-2) 0) (-> self root trans)))
                            (f1-0 (-> self trigger-distance)) ; 409600.0
                            )
                        (< f0-0 (* f1-0 f1-0))
                        )
                      (not (-> self destroyed))
                      )
                 )
        (if (not (logtest? (-> self entity extra perm status) (entity-perm-status subtask-complete)))
          (go-virtual hostile)
          )
        )
      )
    (cond
      (*is-task-done?*
        (when (= (-> self id) *last-turret-id*)
          (go-virtual moribund)
          )
        )
      (else
        #f
        )
      )
    (transform-post)
    )
  )

(defstate explode (kg-turbo-turret)
  :virtual #t
  :enter (behavior ()
    (let ((gp-0 (new 'stack 'joint-exploder-tuning (the-as uint 0))))
      (process-spawn
        joint-exploder
        (art-group-get-by-name *level* "skel-cty-guard-turret-explode" (the-as (pointer level) #f))
        6
        gp-0
        *kg-turbo-turret-exploder-params*
        :name "joint-exploder"
        :to self
        )
      )
    (process-entity-status! self (entity-perm-status subtask-complete) #t)
    (setup-masks (-> self draw) 0 2)
    (set! (-> self root root-prim specific 0) (+ (-> self root root-prim specific 1) -1))
    (let ((a1-0 (new 'stack-no-clear 'event-message-block)))
      (set! (-> a1-0 from) (process->ppointer self))
      (set! (-> a1-0 num-params) 0)
      (set! (-> a1-0 message) 'turret-destroyed)
      (let ((t9-0 send-event-function)
            (v1-4 (-> *game-info* sub-task-list (game-task-node city-destroy-kg-turrets-resolution)))
            )
        (t9-0
          (handle->process (if (-> v1-4 manager)
                               (-> v1-4 manager manager)
                               (the-as handle #f)
                               )
                           )
          a1-0
          )
        )
      )
    (when (-> self minimap)
      (logior! (-> self minimap flags) (minimap-flag fade-out))
      (set! (-> self minimap) #f)
      )
    )
  :code (behavior ()
    (local-vars (v1-6 handle))
    (ja-no-eval :group! cty-guard-turret-pop-up-down-ja :num! (seek! 32.0 0.5) :frame-num 20.0)
    (until (ja-done? 0)
      (let ((a1-4 (new 'stack-no-clear 'vector)))
        (set! (-> a1-4 quad) (-> self root trans quad))
        (+! (-> a1-4 y) 10240.0)
        (spawn (-> self part) a1-4)
        )
        (suspend)
        (ja :num! (seek! 32.0 0.5))
      )
    (suspend-for (seconds 3))
    (set! (-> self root root-prim specific 0) (-> self root root-prim specific 1))
    (setup-masks (-> self draw) 2 0)
    (go-virtual idle)
    )
  :post (behavior ()
    (ja-post)
    )
  )

  (defstate moribund (kg-turbo-turret)
    :virtual #t
    :code sleep-code
    :post (behavior ()
      (let ((a0-0 (new 'stack-no-clear 'vector)))
        (vector+! a0-0 (-> self draw origin) (-> self draw bounds))
        (set! (-> a0-0 w) (-> self draw bounds w))
        (when (and (entity-by-name *last-turret*) (not (sphere-in-view-frustum? (the-as sphere a0-0))))
          (set! *close-task?* #t)
          (cleanup-for-death self)
          (go empty-state)
          )
        )
      (ja-post)
      )
  )

;; WARN: Return type mismatch (pointer process) vs none.
(defmethod kg-turbo-turret-method-34 ((this kg-turbo-turret))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let ((s2-0 (-> this node-list data 7 bone transform))
          (s5-0 (-> this node-list data 8 bone transform))
          (s4-0 (new 'stack-no-clear 'projectile-init-by-other-params))
          )
      (let ((s1-0 (new 'stack-no-clear 'vector))
            (s3-0 (new 'stack-no-clear 'vector))
            )
        (vector<-matrix! s1-0 s2-0)
        (let ((a1-1 s1-0))
          (let ((v1-4 s1-0))
            (let ((a0-2 (-> s2-0 vector 2)))
              (let ((a2-1 10727.424))
                (.mov vf7 a2-1)
                )
              (.lvf vf5 (&-> a0-2 quad))
              )
            (.lvf vf4 (&-> v1-4 quad))
            )
          (.add.x.vf vf6 vf0 vf0 :mask #b1000)
          (.mul.x.vf acc vf5 vf7 :mask #b111)
          (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
          (.svf (&-> a1-1 quad) vf6)
          )
        (vector<-matrix! s3-0 s5-0)
        (let ((a1-3 s3-0))
          (let ((v1-5 s3-0))
            (let ((a0-4 (-> s5-0 vector 2)))
              (let ((a2-3 -10727.424))
                (.mov vf7 a2-3)
                )
              (.lvf vf5 (&-> a0-4 quad))
              )
            (.lvf vf4 (&-> v1-5 quad))
            )
          (.add.x.vf vf6 vf0 vf0 :mask #b1000)
          (.mul.x.vf acc vf5 vf7 :mask #b111)
          (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
          (.svf (&-> a1-3 quad) vf6)
          )
        (set! (-> s4-0 ent) (-> this entity))
        (set! (-> s4-0 charge) 1.0)
        (set! (-> s4-0 options) (projectile-options))
        (set! (-> s4-0 notify-handle) (process->handle this))
        (set! (-> s4-0 owner-handle) (the-as handle #f))
        (set! (-> s4-0 ignore-handle) (process->handle this))
        (let* ((v1-14 *game-info*)
               (a0-14 (+ (-> v1-14 attack-id) 1))
               )
          (set! (-> v1-14 attack-id) a0-14)
          (set! (-> s4-0 attack-id) a0-14)
          )
        (set! (-> s4-0 timeout) (seconds 1.5)) ;; more faster timeout
        (set! (-> s4-0 pos quad) (-> s1-0 quad))
        (set! (-> s4-0 vel quad) (-> s2-0 vector 2 quad))
        (vector-normalize! (-> s4-0 vel) 819200.0)
        (spawn-projectile guard-shot s4-0 this *default-dead-pool*)
        (set! (-> s4-0 pos quad) (-> s3-0 quad))
        )
      (vector-negate! (-> s4-0 vel) (-> s5-0 vector 2))
      (vector-normalize! (-> s4-0 vel) 819200.0)
      (spawn-projectile guard-shot s4-0 this *default-dead-pool*)
      )
    (none)
    )
  )

(defmethod kg-turbo-turret-method-35 ((this kg-turbo-turret))
  (local-vars (sv-192 vector))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let ((s5-0 (handle->process (-> this focus handle))))
      (when s5-0
        (let ((s4-0 (new 'stack-no-clear 'vector)))
          (set! (-> s4-0 quad) (-> (get-trans (the-as process-focusable s5-0) 3) quad))
          (let ((s0-0 (new 'stack-no-clear 'vector)))
            (let ((v1-8 (-> this root trans)))
              (let ((a0-5 *y-vector*))
                (let ((a1-3 10240.0))
                  (.mov vf7 a1-3)
                  )
                (.lvf vf5 (&-> a0-5 quad))
                )
              (.lvf vf4 (&-> v1-8 quad))
              )
            (.add.x.vf vf6 vf0 vf0 :mask #b1000)
            (.mul.x.vf acc vf5 vf7 :mask #b111)
            (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
            (.svf (&-> s0-0 quad) vf6)
            (let ((f30-0 (vector-vector-xz-distance s4-0 s0-0)))
              (let ((f0-2 (* 0.0000012207031 f30-0))
                    (a0-7 s4-0)
                    )
                (let ((v1-10 s4-0))
                  (let ((a1-6 (-> (the-as process-focusable s5-0) root transv)))
                    (let ((a2-0 f0-2))
                      (.mov vf7 a2-0)
                      )
                    (.lvf vf5 (&-> a1-6 quad))
                    )
                  (.lvf vf4 (&-> v1-10 quad))
                  )
                (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                (.mul.x.vf acc vf5 vf7 :mask #b111)
                (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                (.svf (&-> a0-7 quad) vf6)
                )
              (let ((s3-1 (vector-! (new 'stack-no-clear 'vector) s4-0 s0-0))
                    (s1-0 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> this root quat)))
                    )
                (set! sv-192 (new 'stack-no-clear 'vector))
                (let ((s2-0 (new 'stack-no-clear 'vector)))
                  (-> this node-list data 6 bone transform)
                  (-> this node-list data 7 bone transform)
                  (-> this node-list data 8 bone transform)
                  (vector-rotate90-around-y! sv-192 s3-1)
                  (set! (-> sv-192 y) 0.0)
                  (vector-normalize! sv-192 1.0)
                  (let* ((f26-0 (vector-vector-xz-distance-squared s0-0 s4-0))
                         (f0-4 7389.184)
                         (f28-0 (* f0-4 f0-4))
                         (t9-6 vector-vector-xz-distance-squared)
                         (a0-13 (new 'stack-no-clear 'vector))
                         )
                    (let ((v1-27 7389.184))
                      (.mov vf7 v1-27)
                      )
                    (.lvf vf5 (&-> sv-192 quad))
                    (.lvf vf4 (&-> s0-0 quad))
                    (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                    (.mul.x.vf acc vf5 vf7 :mask #b111)
                    (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                    (.svf (&-> a0-13 quad) vf6)
                    (let* ((f2-0 (t9-6 a0-13 s4-0))
                           (f28-1 (acos (fmax -1.0 (fmin 1.0 (/ (- (- f26-0 f28-0) f2-0) (* -2.0 (sqrtf f2-0) (sqrtf f28-0)))))))
                           )
                      (let ((s0-1 (new 'stack-no-clear 'vector))
                            (s4-1 (new 'stack-no-clear 'vector))
                            )
                        (if (< f28-1 11832.889)
                            (set! f28-1 11832.889)
                            )
                        (rot-zxy-from-vector! s0-1 s1-0)
                        (rot-zxy-from-vector! s2-0 s3-1)
                        (set! (-> s4-1 x) (deg- (-> s2-0 x) (-> s0-1 x)))
                        (set! (-> s4-1 y) (deg- (-> s2-0 y) (-> s0-1 y)))
                        (cond
                          ((focus-test? (the-as process-focusable s5-0) pilot)
                           (set! (-> this angle-turret) (deg-seek (-> this angle-turret) (-> s4-1 y) (* 36408.89 (seconds-per-frame))))
                           (set! (-> this angle-guns) (deg-seek (-> this angle-guns) (-> s4-1 x) (* 7281.778 (seconds-per-frame))))
                           )
                          (else
                            (set! (-> this angle-turret) (deg-seek (-> this angle-turret) (-> s4-1 y) (* 36408.89 (seconds-per-frame)))) ;; old - 18204.445
                            (set! (-> this angle-guns) (deg-seek (-> this angle-guns) (-> s4-1 x) (* 7281.778 (seconds-per-frame))))
                            )
                          )
                        (quaternion-axis-angle! (-> this jm-turret quat) 0.0 1.0 0.0 (-> this angle-turret))
                        (when (= (+ (fabs (- (-> this angle-turret) (-> s4-1 y))) (fabs (- (-> this angle-guns) (-> s4-1 x)))) 0.0)
                          (set! (-> this next-time-shot) (+ (current-time) (seconds 1)))
                          (set! (-> this num-shots) (the-as uint 0))
                          0
                          )
                        )
                      (let ((s5-1 (new 'stack-no-clear 'quaternion)))
                        (let ((f0-42 (/ 45511.11 (* 0.00024414062 f30-0))))
                          (quaternion-axis-angle! s5-1 1.0 0.0 0.0 (fmax (fmin (-> this angle-guns) f0-42) (- f0-42)))
                          )
                        (quaternion*!
                          (-> this jm-gunsL quat)
                          (quaternion-axis-angle! (new 'stack-no-clear 'quaternion) 0.0 1.0 0.0 (+ -16384.0 f28-1))
                          s5-1
                          )
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        (quaternion-copy! (-> this jm-gunsR quat) (-> this jm-gunsL quat))
        )
      )
    )
  )

(defstate hostile (kg-turbo-turret)
  :virtual #t
  :event kg-turbo-turret-event-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (set! (-> self num-shots) (the-as uint 0))
    0
    )
  :trans (behavior ()
    '()
    )
  :code (behavior ()
    (ja-no-eval :group! cty-guard-turret-pop-up-down-ja :num! (seek! 20.0 0.5) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! 20.0 0.5))
      )
    (until #f
      (cond
        ((zero? (-> self next-time-shot))
         (kg-turbo-turret-method-35 self)
         )
        ((>= (current-time) (-> self next-time-shot))
         (kg-turbo-turret-method-34 self)
         (+! (-> self num-shots) 1)
         (cond
           ((= (-> self num-shots) 5)
            (set! (-> self next-time-shot) 0)
            0
            )
           (else
             (set! (-> self next-time-shot) (+ (current-time) (seconds 0.1)))
             )
           )
         )
        )
      (suspend)
      (let ((gp-0 (handle->process (-> self focus handle))))
        (cond
          ((and gp-0
                (let ((f0-5 (vector-vector-xz-distance-squared (get-trans (the-as process-focusable gp-0) 0) (-> self root trans)))
                      (f1-0 491520.0)
                      )
                  (< f0-5 (* f1-0 f1-0))
                  )
                )
           )
          (else
            (goto cfg-36)
            )
          )
        )
      )
    #f
    (label cfg-36)
    (ja-no-eval :group! cty-guard-turret-pop-up-down-ja :num! (seek! 32.0 0.5) :frame-num 20.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! 32.0 0.5))
      )
    (go-virtual idle)
    )
  :post (behavior ()
    (transform-post)
    )
  )

(defmethod relocate ((this kg-turbo-turret) (offset int))
  (if (nonzero? (-> this jm-turret))
      (&+! (-> this jm-turret) offset)
      )
  (if (nonzero? (-> this jm-gunsL))
      (&+! (-> this jm-gunsL) offset)
      )
  (if (nonzero? (-> this jm-gunsR))
      (&+! (-> this jm-gunsR) offset)
      )
  (call-parent-method this offset)
  )

(defmethod kg-turbo-turret-method-32 ((this kg-turbo-turret))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (set! (-> s5-0 penetrated-by) (penetrate
                                    lunge
                                    flop
                                    punch
                                    spin
                                    roll
                                    uppercut
                                    bonk
                                    tube
                                    vehicle
                                    flut-attack
                                    board
                                    mech-punch
                                    dark-punch
                                    )
          )
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 4) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 5))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid rideable))
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 26624.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-13 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-13 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-13 prim-core collide-with) (collide-spec jak player-list tobot))
      (set! (-> v1-13 prim-core action) (collide-action solid rideable))
      (set! (-> v1-13 transform-index) 4)
      (set-vector! (-> v1-13 local-sphere) -6144.0 0.0 0.0 10649.6)
      )
    (let ((v1-15 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-15 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-15 prim-core collide-with) (collide-spec jak player-list tobot))
      (set! (-> v1-15 prim-core action) (collide-action solid rideable))
      (set! (-> v1-15 transform-index) 5)
      (set-vector! (-> v1-15 local-sphere) 6144.0 0.0 0.0 10649.6)
      )
    (let ((v1-17 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 2) (the-as uint 0))))
      (set! (-> v1-17 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-17 prim-core collide-with) (collide-spec jak player-list tobot))
      (set! (-> v1-17 prim-core action) (collide-action solid rideable))
      (set! (-> v1-17 transform-index) 3)
      (set-vector! (-> v1-17 local-sphere) 0.0 0.0 0.0 14336.0)
      )
    (let ((v1-19 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-19 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-19 prim-core collide-with) (collide-spec jak player-list tobot))
      (set! (-> v1-19 prim-core action) (collide-action solid))
      (set! (-> v1-19 transform-index) 6)
      (set-vector! (-> v1-19 local-sphere) 0.0 -8192.0 0.0 13107.2)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-22 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-22 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-22 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

(defmethod kg-turbo-turret-method-33 ((this kg-turbo-turret))
  (logior! (-> this mask) (process-mask enemy))
  0
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this kg-turbo-turret) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
   This commonly includes things such as:
   - stack size
   - collision information
   - loading the skeleton group / bones
   - sounds"
  (local-vars (v1-23 handle))
  (with-pp
    (kg-turbo-turret-method-32 this)
    (set! (-> this entity) arg0)
    (process-drawable-from-entity! this arg0)
    (ctywide-entity-hack)
    (initialize-skeleton
      this
      (the-as skeleton-group (art-group-get-by-name *level* "skel-cty-guard-turret" (the-as (pointer level) #f)))
      (the-as pair 0)
      )
    (kg-turbo-turret-method-33 this)
    (reset-to-collide-spec (-> this focus) (collide-spec jak player-list))
    (set! (-> this jm-turret) (new 'process 'joint-mod (joint-mod-mode joint-set*) this 6))
    (set! (-> this jm-gunsL) (new 'process 'joint-mod (joint-mod-mode joint-set*) this 7))
    (set! (-> this jm-gunsR) (new 'process 'joint-mod (joint-mod-mode joint-set*) this 8))
    (set! (-> this part) (create-launch-control (-> *part-group-id-table* 186) this))
    (set! (-> this id) (res-lump-value arg0 'extra-id int :default (the-as uint128 -1) :time -1000000000.0))
    (set! (-> this destroyed) #f)
    (set! (-> this hit-points) 6)
    (set! (-> this minimap) (add-icon! *minimap* this (the-as uint 129) (the-as int #f) (the-as vector #t) 0))
    (set! (-> this trigger-distance) (res-lump-float (-> this entity) 'distance :default 409600.0))
    (go (method-of-object this idle))
    (none)
    )
  )

(deftype destroy-turret-bombbot (bombbot)
  ()
  (:state-methods
    moribund
    )
  )

(defmethod bombbot-method-196 ((this destroy-turret-bombbot) (arg0 vector))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let ((gp-0 (the-as process-drawable #f)))
      (let ((f30-0 (the-as float #x7f800000))
            (s3-0 (new 'stack-no-clear 'array 'collide-shape 64))
            )
        (countdown (s2-0 (fill-actor-list-for-box *actor-hash* arg0 s3-0 64))
          (let* ((s1-0 (-> s3-0 s2-0))
                 (a0-3 (if (type? s1-0 collide-shape)
                           s1-0
                           )
                       )
                 )
            (when a0-3
              (let* ((s0-0 (-> a0-3 process))
                     (s1-1 (if (type? s0-0 process-focusable)
                               s0-0
                               )
                           )
                     )
                (when (and s1-1
                           (!= this s1-1)
                           (not (focus-test? this inactive))
                           (not (focus-test? this disable))
                           (not (focus-test? this dead))
                           (not (logtest? (process-mask guard) (-> s1-1 mask)))
                           (not (logtest? (process-mask crate) (-> s1-1 mask)))
                           (logtest? (process-mask guard vehicle) (-> s1-1 mask))
                           s1-1
                           (not (logtest? (-> (the-as process-focusable s1-1) focus-status) (focus-status disable dead ignore grabbed)))
                           )
                  (let ((f0-0 (vector-vector-xz-distance (-> this root trans) (-> (the-as process-focusable s1-1) root trans))))
                    (when (or (not gp-0) (< f0-0 f30-0))
                      (set! gp-0 s1-1)
                      (set! f30-0 f0-0)
                      )
                    )
                  )
                )
              )
            )
          )
        )
      (if (and *target* (< (vector-vector-distance (target-pos 0) arg0) (-> arg0 w)))
          (set! gp-0 *target*)
          )
      (cond
        (gp-0
          (set! (-> this target-pos quad) (-> (get-trans (the-as process-focusable gp-0) 3) quad))
          (let ((v1-34 (-> this target-pos)))
            (let ((a0-16 (-> gp-0 root trans)))
              (let ((a1-8 (-> gp-0 root transv)))
                (let ((a2-1 0.0))
                  (.mov vf7 a2-1)
                  )
                (.lvf vf5 (&-> a1-8 quad))
                )
              (.lvf vf4 (&-> a0-16 quad))
              )
            (.add.x.vf vf6 vf0 vf0 :mask #b1000)
            (.mul.x.vf acc vf5 vf7 :mask #b111)
            (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
            (.svf (&-> v1-34 quad) vf6)
            )
          (set! (-> this start-target-pos quad) (-> gp-0 root trans quad))
          (set! (-> this start-target-vel quad) (-> gp-0 root transv quad))
          (try-update-focus (-> this focus) (the-as process-focusable gp-0) this)
          )
        (else
          (clear-focused (-> this focus))
          )
        )
      )
    0
    (none)
    )
  )

(defmethod event-handler ((this destroy-turret-bombbot) (arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('nav-mesh-kill)
     (change-to *default-nav-mesh* this)
     #t
     )
    (('hit-flinch)
     (cond
       ((= (-> this hit-points) 0.0)
        (if (not (and (-> this next-state) (= (-> this next-state name) 'die)))
            (go-die this)
            )
        )
       (else
        (when (!= (-> arg0 type) guard-shot)
         (let ((a1-2 (-> arg3 param 1)))
           (when arg0
             (let ((v1-8 (find-offending-process-focusable arg0 (the-as attack-info a1-2))))
               (when v1-8
                 (let ((s5-1 (new 'stack-no-clear 'vector)))
                   (let ((s4-1 (new 'stack-no-clear 'vector)))
                     (set! (-> s4-1 quad) (-> v1-8 root trans quad))
                     (let ((s3-1 (matrix->trans (-> this node-list data 3 bone transform) (new 'stack-no-clear 'vector))))
                       (+! (-> s4-1 x) (* 4096.0 (rand-vu-float-range -20.0 20.0)))
                       (+! (-> s4-1 y) (* 4096.0 (rand-vu-float-range -20.0 20.0)))
                       (+! (-> s4-1 z) (* 4096.0 (rand-vu-float-range -20.0 20.0)))
                       (vector-! s5-1 s3-1 s4-1)
                       )
                     )
                   (vector-normalize! s5-1 4096000.0)
                   (vector-inv-orient-by-quat! s5-1 s5-1 (-> this root quat))
                   (apply-impact!
                     (-> this rigidbody)
                     (rigid-body-control-method-25 (-> this rigidbody) (new 'stack-no-clear 'vector))
                     s5-1
                     )
                   )
                 )
               )
             )
           )
         (play-damage-sound this 0)
         'back
          )
         )
       )
     )
    (('explode)
     (if (not (and (-> this next-state) (= (-> this next-state name) 'explode)))
         (go (method-of-object this explode))
         )
     )
    (('blow-wall)
     (go (method-of-object this blow-wall))
     )
    (('touched 'touch 'attack)
     (if (logtest? (process-mask vehicle) (-> arg0 mask))
         (send-event
           arg0
           'attack
           (-> arg3 param 0)
           (static-attack-info
             :mask (vehicle-impulse-factor)
             ((id (new-attack-id)) (damage 2.0) (vehicle-damage-factor 1.0) (vehicle-impulse-factor 1.0) (mode 'mine))
             )
           )
         )
     ((method-of-type nav-enemy event-handler) this arg0 arg1 arg2 arg3)
     )
    (else
      ((method-of-type nav-enemy event-handler) this arg0 arg1 arg2 arg3)
      )
    )
  )

(defmethod go-fallback-init ((this destroy-turret-bombbot))
  "If there's no specific settings for initial state, go to this state after spawning."
  (go (method-of-object this hostile))
  )

(defstate hostile (destroy-turret-bombbot)
  :virtual #t
  :trans (behavior ()
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           )
      (init-vf0-vector)
      (when (< (-> self next-target) (current-time))
        (let ((a1-0 (new 'stack-no-clear 'vector)))
          (set! (-> a1-0 quad) (-> self root trans quad))
          (set! (-> a1-0 w) 409600.0)
          (bombbot-method-196 self a1-0)
          )
        (set! (-> self next-target) (+ (current-time) (seconds 4)))
        (set! (-> self gun-type) (the-as uint 0))
        0
        )
      (let ((gp-0 (the-as process-focusable (handle->process (-> self focus handle)))))
        (when gp-0
          (when (< (current-time) (+ (-> self next-target) (seconds -2)))
            (set-time! (-> self start-target))
            (set! (-> self start-target-pos quad) (-> (get-trans gp-0 3) quad))
            (set! (-> self start-target-vel quad) (-> gp-0 root transv quad))
            (vector-! (-> self target-delta) (-> gp-0 root trans) (-> self root trans))
            )
          (let ((a1-5 (-> self target-pos)))
            (let ((v1-26 (-> self start-target-pos)))
              (let ((a0-17 (-> self start-target-vel)))
                (let ((a2-4 (* 0.0033333334 (the float (- (current-time) (-> self start-target))))))
                  (.mov vf7 a2-4)
                  )
                (.lvf vf5 (&-> a0-17 quad))
                )
              (.lvf vf4 (&-> v1-26 quad))
              )
            (.add.x.vf vf6 vf0 vf0 :mask #b1000)
            (.mul.x.vf acc vf5 vf7 :mask #b111)
            (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
            (.svf (&-> a1-5 quad) vf6)
            )
          (set! (-> self target-pos quad) (-> self start-target-pos quad))
          (if (< (+ (-> self next-target) (seconds -1)) (current-time))
              (bombbot-method-197 self)
              (bombbot-method-204 self)
              )
          )
        )
      (bombbot-method-205 self)
      (new 'stack-no-clear 'vector)
      (let ((f0-4 (* 0.25 (+ (-> self feet 0 next-position y)
                             (-> self feet 1 next-position y)
                             (-> self feet 2 next-position y)
                             (-> self feet 3 next-position y)
                             )
                     )
                  )
            )
        (if (!= (-> self nav state mesh) *default-nav-mesh*)
            (+! (-> self root trans y) (* 4.0 (seconds-per-frame) (- f0-4 (-> self root trans y))))
            )
        )
      (if (= (vector-length (-> self root transv)) 0.0)
          (set-time! (-> self state-time))
          )
      (bombbot-method-202 self)
      (bombbot-method-195 self)
      )
    )
  :post (behavior ()
    (cond
      ((= (-> self nav state mesh) *default-nav-mesh*)
       (enemy-common-post self)
       (update-transforms (-> self root))
       )
      (else
        (if (logtest? (-> self nav state flags) (nav-state-flag at-target))
            (nav-enemy-method-164 self)
            )
        (set! (-> (new 'stack-no-clear 'vector) quad) (-> self nav state target-pos quad))
        (nav-enemy-method-187 self)
        )
      )

      (if *is-task-done?*
        (go-virtual moribund)
        )
    )
  )

  (defstate moribund (destroy-turret-bombbot)
    :virtual #t
    :code sleep-code
    :post (behavior ()
      (let ((a0-0 (new 'stack-no-clear 'vector)))
        (vector+! a0-0 (-> self draw origin) (-> self draw bounds))
        (set! (-> a0-0 w) (-> self draw bounds w))
        (when (not (sphere-in-view-frustum? (the-as sphere a0-0)))
          (cleanup-for-death self)
          (go empty-state)
          )
        )
      (ja-post)
      )
  )

(defmethod init-from-entity! ((this destroy-turret-bombbot) (arg0 entity-actor))
  (stack-size-set! (-> this main-thread) 512)
  (init-enemy-collision! this)
  (process-drawable-from-entity! this arg0)
  (set! (-> *bombbot-nav-enemy-info* nav-mesh) *default-nav-mesh*)
  (init-enemy! this)
  (set! (-> this shot-count) (the-as uint 10))
  (set! (-> this last-trans quad) (-> this root trans quad))
  (logior! (-> this mask) (process-mask kg-robot))
  (set! (-> this minimap) #f)
  (logior! (-> this mask) (process-mask enemy))
  (set-time! (-> this stop-shoot))
  (set! (-> this shoot-duration) 5.0)
  (set! (-> this draw light-index) (the-as uint 10))
  (set! (-> this hit-points) 35.0)
  (let ((v1-19 (-> this nav state))
        (a0-13 (-> this root trans))
        )
    (logclear! (-> v1-19 flags) (nav-state-flag directional-mode))
    (logior! (-> v1-19 flags) (nav-state-flag target-poly-dirty))
    (set! (-> v1-19 target-pos quad) (-> a0-13 quad))
    )
  0
  (set! (-> this max-hit-points) (-> this hit-points))
  (go (method-of-object this hostile))
  )