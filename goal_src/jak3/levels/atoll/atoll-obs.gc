(deftype ato-move-plat (plat)
  ()
  )


(defskelgroup skel-fac-move-pla fac-move-plat-b fac-move-plat-b-lod0-jg fac-move-plat-b-idle-ja
              ((fac-move-plat-b-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 9)
              )

(defmethod get-art-group ((this ato-move-plat))
  (art-group-get-by-name *level* "skel-fac-move-pla" (the-as (pointer level) #f))
  )

;; WARN: Return type mismatch float vs none.
(defmethod init-collision! ((this ato-move-plat))
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
    (let ((s4-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-spec pusher))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid rideable))
      (set! (-> s4-0 transform-index) 3)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 22528.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) s4-0)
      )
    (pusher-init s5-0)
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-12 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-12 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-12 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  (set! (-> this root pause-adjust-distance) 327680.0)
  (none)
  )

(defmethod deactivate ((this ato-move-plat))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  ((method-of-type plat deactivate) this)
  (none)
  )

(defmethod go-initial-state ((this ato-move-plat))
  (let ((f0-0 (res-lump-float (-> this entity) 'fac-plat-dead-start :default -1.0)))
    (if (>= f0-0 0.0)
        (get-point-at-percent-along-path! (-> this path) (-> this basetrans) f0-0 'interp)
        )
    )
  (if (and (nonzero? (res-lump-value (-> this entity) 'fac-plat-reset-stopped uint128 :time -1000000000.0))
           (not (task-closed? (res-lump-struct (-> this entity) 'task-name string)))
           )
      (go (method-of-object this plat-idle))
      (go (method-of-object this plat-path-active))
      )
  )

(defstate plat-idle (ato-move-plat)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('trigger)
       (go-virtual plat-path-active)
       )
      (('bonk)
       (start-bounce! self)
       )
      )
    )
  :trans (behavior ()
    (call-parent-state-handler trans)
    )
  :code (behavior ()
    (call-parent-state-handler code)
    )
  )

(defstate plat-path-active (ato-move-plat)
  :virtual #t
  :event plat-event
  :exit (behavior ()
    (sound-stop (-> self sound-id))
    )
  :trans (behavior ()
    (set! (-> self path-pos) (get-norm! (-> self sync) 0))
    (get-point-at-percent-along-path! (-> self path) (-> self basetrans) (-> self path-pos) 'interp)
    (if (< (vector-vector-distance (-> self root trans) (ear-trans 0)) 163840.0)
        (sound-play "move-plat-loop" :id (-> self sound-id) :position (-> self root trans))
        )
    (let ((v1-11 (shr (-> self sync period) 1)))
      (if (< (mod (current-time) (the-as time-frame v1-11))
             (mod (-> self clock old-frame-counter) (the-as time-frame v1-11))
             )
          (sound-play "move-plat-hit")
          )
      )
    (plat-trans)
    )
  :code (behavior ()
    (until #f
      (ja-no-eval :group! (ja-group) :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    )
  :post plat-post
  )