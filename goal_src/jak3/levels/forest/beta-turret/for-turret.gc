;;-*-Lisp-*-
(in-package goal)

;; definition for method 15 of type hud-for-turret-health
;; WARN: Return type mismatch int vs none.
;; ERROR: Failed store: (s.f! (+ this 1040) f1-6) at op 37
;; ERROR: Failed store: (s.w! (+ this 1044) 0) at op 38
(defmethod draw ((this hud-for-turret-health))
  (set-hud-piece-position!
    (the-as hud-sprite (&-> this sprites 3 flags))
    256
    (- 40 (the int (* 50.0 (-> this offset))))
    )
  (set! (-> this sprites 3 scale-y) 0.000000000000000000000000000000000000023509865)
  (set-as-offset-from!
    (the-as hud-sprite (&-> this sprites 4 flags))
    (the-as vector4w (&-> this sprites 3 flags))
    -71
    -5
    )
  (set! (-> this sprites 4 scale-y) 0.000000000000000000000000000000000000023509865)
  (let ((f0-3 (the-as float (-> this values 0 current))))
    (set! (-> this sprites 4 tid) (the-as texture-id (* 255.0 (- 1.0 f0-3))))
    (let ((f1-6 (the int (* 255.0 f0-3))))
      (s.f! (+ this 1040) f1-6)
      )
    (s.w! (+ this 1044) 0)
    (set! (-> this sprites 5 pos y) (the-as int (* 35.5 f0-3)))
    )
  ((method-of-type hud draw) this)
  0
  (none)
  )

;; definition for method 16 of type hud-for-turret-health
;; ERROR: failed type prop at 1: Could not figure out load: (set! f0 (l.f (+ v1 656)))
(defmethod update-values! ((a0-0 hud-for-turret-health))
  (local-vars
    (v0-0 none)
    (v0-1 none)
    (v1-0 game-info)
    (v1-1 none)
    (v1-2 none)
    (v1-3 none)
    (a1-0 none)
    (t9-0 none)
    (f0-0 none)
    (f0-1 none)
    )
  (set! v1-0 *game-info*)
  (set! f0-0 (the-as none (l.f (+ v1-0 656))))
  (set! f0-1 (the-as none (f2i f0-0)))
  (set! (-> a0-0 values 0 target) (the-as int f0-1))
  (set! v1-1 (the-as none -2))
  (set! a1-0 (the-as none (-> a0-0 flags)))
  (set! v1-2 (the-as none (logand v1-1 a1-0)))
  (set! (-> a0-0 flags) (the-as hud-flags v1-2))
  (set! v1-3 (the-as none hud))
  (set! t9-0 (the-as none (l.wu (+ v1-3 80))))
  (call!)
  (set! v0-1 (the-as none 0))
  (ret-none)
  )

;; definition for method 17 of type hud-for-turret-health
;; WARN: Return type mismatch int vs none.
;; ERROR: Failed store: (s.w! (+ this 2972) v1-3) at op 19
(defmethod init-callback ((this hud-for-turret-health))
  (set! (-> this level) (level-get *level* 'lformach))
  (let ((v1-3
          (add-process *gui-control* this (gui-channel hud-upper-center-2) (gui-action hidden) (-> this name) 81920.0 0)
          )
        )
    (s.w! (+ this 2972) v1-3)
    )
  (logior! (-> this flags) (hud-flags show))
  (set! (-> this sprites 4 color x) (the-as int (lookup-texture-by-id (new 'static 'texture-id :page #x613))))
  (set! (-> this sprites 4 pos x) 8)
  (set! (-> this sprites 4 pos y) (the-as int 1.2))
  (set! (-> this sprites 4 pos z) (the-as int 1.2))
  (set! (-> this sprites 5 color x) (the-as int (get-texture common-white common)))
  (set! (-> this sprites 5 pos x) 0)
  (set! (-> this sprites 5 pos y) (the-as int 0.0))
  (set! (-> this sprites 5 pos z) (the-as int 3.0))
  0
  (none)
  )

;; definition of type hud-for-turret-arrows
(deftype hud-for-turret-arrows (hud)
  ((offscreen  uint8  :offset 2980)
   (alpha      float  2)
   )
  )

;; definition for method 3 of type hud-for-turret-arrows
(defmethod inspect ((this hud-for-turret-arrows))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type hud inspect)))
    (t9-0 this)
    )
  (format #t "~2Toffscreen: ~D~%" (-> this offscreen))
  (format #t "~2Talpha[2] @ #x~X~%" (-> this alpha))
  (label cfg-4)
  this
  )

;; definition for method 15 of type hud-for-turret-arrows
;; WARN: Return type mismatch int vs none.
;; ERROR: Failed store: (s.w! (+ this 984) 0) at op 1
;; ERROR: Failed store: (s.f! (+ this 984) f0-1) at op 9
;; ERROR: Failed store: (s.w! (+ this 1048) 0) at op 10
;; ERROR: Failed store: (s.f! (+ this 1048) f0-3) at op 18
(defmethod draw ((this hud-for-turret-arrows))
  (s.w! (+ this 984) 0)
  (set-hud-piece-position! (the-as hud-sprite (&-> this sprites 3 flags)) 32 208)
  (let ((f0-1 (the int (-> this alpha 0))))
    (s.f! (+ this 984) f0-1)
    )
  (s.w! (+ this 1048) 0)
  (set-hud-piece-position! (the-as hud-sprite (&-> this sprites 4 flags)) 480 208)
  (let ((f0-3 (the int (-> this alpha 1))))
    (s.f! (+ this 1048) f0-3)
    )
  ((method-of-type hud draw) this)
  0
  (none)
  )

;; definition for method 16 of type hud-for-turret-arrows
;; WARN: Return type mismatch int vs none.
(defmethod update-values! ((this hud-for-turret-arrows))
  (logclear! (-> this flags) (hud-flags disable))
  (when (not (logtest? (-> *kernel-context* prevent-from-run) (process-mask pause)))
    (dotimes (s5-0 2)
      (if (not (logtest? (-> this offscreen) (ash 1 s5-0)))
          (seek! (-> this alpha s5-0) 0.0 (* 256.0 (seconds-per-frame)))
          (seek!
            (-> this alpha s5-0)
            (+ 80.0 (* 32.0 (sin (* 218.45334 (the float (mod (current-time) 300))))))
            (* 128.0 (seconds-per-frame))
            )
          )
      )
    )
  ((method-of-type hud update-values!) this)
  0
  (none)
  )

;; definition for method 17 of type hud-for-turret-arrows
;; WARN: Return type mismatch int vs none.
;; ERROR: Failed store: (s.w! (+ this 2972) v1-1) at op 12
(defmethod init-callback ((this hud-for-turret-arrows))
  (let ((v1-1
          (add-process *gui-control* this (gui-channel hud-middle-left) (gui-action hidden) (-> this name) 81920.0 0)
          )
        )
    (s.w! (+ this 2972) v1-1)
    )
  (logior! (-> this flags) (hud-flags show))
  (set! (-> this offscreen) (the-as uint 0))
  (set! (-> this alpha 0) 0.0)
  (set! (-> this alpha 1) 0.0)
  (set! (-> this sprites 4 color x) (the-as int (lookup-texture-by-id (new 'static 'texture-id :page #x966))))
  (set! (-> this sprites 4 pos x) 9)
  (set! (-> this sprites 4 pos y) (the-as int 1.0))
  (set! (-> this sprites 4 pos z) (the-as int 1.0))
  (set! (-> this sprites 5 color x) (the-as int (lookup-texture-by-id (new 'static 'texture-id :page #x966))))
  (set! (-> this sprites 5 pos x) 8)
  (set! (-> this sprites 5 pos y) (the-as int 1.0))
  (set! (-> this sprites 5 pos z) (the-as int 1.0))
  0
  (none)
  )

;; definition for method 18 of type hud-for-turret-arrows
(defmethod event-callback ((this hud-for-turret-arrows) (arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('reset-arrows)
     (set! (-> this offscreen) (the-as uint 0))
     0
     )
    (('off-to-left)
     (logior! (-> this offscreen) 1)
     )
    (('off-to-right)
     (logior! (-> this offscreen) 2)
     )
    )
  ((method-of-type hud event-callback) this arg0 arg1 arg2 arg3)
  )

;; definition of type for-turret-blocker
(deftype for-turret-blocker (process-drawable)
  ((root  collide-shape :override)
   )
  (:state-methods
    idle
    )
  )

;; definition for method 3 of type for-turret-blocker
(defmethod inspect ((this for-turret-blocker))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type process-drawable inspect)))
    (t9-0 this)
    )
  (label cfg-4)
  this
  )

;; failed to figure out what this is:
(defstate idle (for-turret-blocker)
  :virtual #t
  :code sleep-code
  )

;; definition for function for-turret-blocker-init-by-other
;; INFO: Used lq/sq
(defbehavior for-turret-blocker-init-by-other for-turret-blocker ((arg0 vector) (arg1 entity))
  (process-entity-set! self arg1)
  (let ((s5-0 (new 'process 'collide-shape self (collide-list-enum usually-hit-by-player))))
    (let ((v1-2 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-2 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-2 prim-core action) (collide-action solid))
      (set-vector! (-> v1-2 local-sphere) 0.0 8192.0 0.0 9830.4)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) v1-2)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-5 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-5 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-5 prim-core collide-with))
      )
    (set! (-> self root) s5-0)
    )
  (vector-copy! (-> self root trans) arg0)
  (ja-post)
  (update-transforms (-> self root))
  (go-virtual idle)
  )

;; definition of type for-turret
(deftype for-turret (target-turret)
  ((aim-pos            vector  :inline)
   (muzzle-pos         vector  :inline)
   (hud-arrows         handle)
   (battle-entity      entity)
   (focus-handle       handle)
   (fire-timer         time-frame)
   (nav-mesh           nav-mesh)
   (projectile-handle  handle)
   (mode-sound-bank    connection)
   (actor-group        (pointer actor-group))
   (actor-group-count  int32)
   )
  )

;; definition for method 3 of type for-turret
(defmethod inspect ((this for-turret))
  (when (not this)
    (set! this this)
    (goto cfg-7)
    )
  (let ((t9-0 (method-of-type target-turret inspect)))
    (t9-0 this)
    )
  (format #t "~2Taim-pos: #<vector @ #x~X>~%" (-> this aim-pos))
  (format #t "~2Tmuzzle-pos: #<vector @ #x~X>~%" (-> this muzzle-pos))
  (format #t "~2Thud-arrows: ~D~%" (-> this hud-arrows))
  (format #t "~2Tbattle-entity: ~A~%" (-> this battle-entity))
  (format #t "~2Tfocus-handle: ~D~%" (-> this focus-handle))
  (format #t "~2Tfire-timer: ~D~%" (-> this fire-timer))
  (format #t "~2Tnav-mesh: ~A~%" (-> this nav-mesh))
  (format #t "~2Tprojectile-handle: ~D~%" (-> this projectile-handle))
  (format #t "~2Tmode-sound-bank: #<connection @ #x~X>~%" (-> this mode-sound-bank))
  (format #t "~2Tactor-group: #x~X~%" (-> this actor-group))
  (dotimes (s5-0 (-> this actor-group-count))
    (format #t "~T  [~D]~2Tactor-group: ~`actor-group`P~%" s5-0 (-> this actor-group s5-0))
    )
  (format #t "~2Tactor-group-count: ~D~%" (-> this actor-group-count))
  (label cfg-7)
  this
  )

;; definition for symbol *for-turret-params*, type target-turret-params
(define *for-turret-params* (new 'static 'target-turret-params
                              :fire-interval (seconds 0.2)
                              :max-health 16.0
                              :roty-accel -76458.664
                              :roty-friction 0.92
                              :rotyv-max 21845.334
                              :rotx-accel -58254.223
                              :rotx-friction 0.88
                              :rotxv-max 10922.667
                              :rotx-min -7281.778
                              :rotx-max 3640.889
                              )
        )

;; failed to figure out what this is:
(defskelgroup skel-for-turret-explode for-turret for-turret-explode-lod0-jg -1
              ((for-turret-explode-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 1.8 0.7 15)
              )

;; definition for symbol *for-turret-exploder-params*, type joint-exploder-static-params
(define *for-turret-exploder-params* <static-data L233>)

;; definition for method 35 of type for-turret
;; WARN: Return type mismatch int vs none.
(defmethod target-turret-method-35 ((this for-turret))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum hit-by-others))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 5) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 6))
      (set! (-> s4-0 prim-core collide-as) (collide-spec bot obstacle camera-blocker))
      (set! (-> s4-0 prim-core action) (collide-action solid no-standon))
      (set-vector! (-> s4-0 local-sphere) 0.0 7372.8 0.0 22528.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-11 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-11 prim-core collide-as) (collide-spec bot obstacle camera-blocker))
      (set! (-> v1-11 prim-core action) (collide-action solid no-standon))
      (set! (-> v1-11 transform-index) 3)
      (set-vector! (-> v1-11 local-sphere) 0.0 8192.0 0.0 9830.4)
      )
    (let ((v1-13 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-13 prim-core collide-as) (collide-spec bot obstacle camera-blocker))
      (set! (-> v1-13 prim-core action) (collide-action solid no-standon))
      (set-vector! (-> v1-13 local-sphere) 0.0 -2048.0 0.0 12288.0)
      )
    (let ((v1-15 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-15 prim-core collide-as) (collide-spec bot camera-blocker))
      (set! (-> v1-15 prim-core action) (collide-action solid no-standon))
      (set! (-> v1-15 transform-index) 10)
      (set-vector! (-> v1-15 local-sphere) 0.0 1228.8 -819.2 4915.2)
      )
    (let ((v1-17 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-17 prim-core collide-as) (collide-spec bot obstacle camera-blocker))
      (set! (-> v1-17 prim-core action) (collide-action solid no-standon))
      (set! (-> v1-17 transform-index) 3)
      (set-vector! (-> v1-17 local-sphere) 0.0 8192.0 9011.2 5734.4)
      )
    (let ((v1-19 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-19 transform-index) 3)
      (set-vector! (-> v1-19 local-sphere) 0.0 6553.6 0.0 12288.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-22 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-22 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-22 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

;; failed to figure out what this is:
(defstate idle (for-turret)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('grab)
       (when (not (-> self rider))
         (set! (-> self rider) (process->handle proc))
         (go-virtual gunner-setup)
         )
       )
      (else
        ((-> (method-of-type target-turret idle) event) proc argc message block)
        )
      )
    )
  )

;; failed to figure out what this is:
(defstate setup (for-turret)
  :virtual #t
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type target-turret setup) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (when (> (-> self actor-group-count) 0)
      (let ((gp-0 (-> self actor-group 0)))
        (dotimes (s5-0 (-> gp-0 length))
          (let ((a1-0 (new 'stack-no-clear 'event-message-block)))
            (set! (-> a1-0 from) (process->ppointer self))
            (set! (-> a1-0 num-params) 0)
            (set! (-> a1-0 message) 'trigger)
            (let ((t9-1 send-event-function)
                  (v1-11 (-> gp-0 data s5-0 actor))
                  )
              (t9-1
                (if v1-11
                    (-> v1-11 extra process)
                    )
                a1-0
                )
              )
            )
          )
        )
      )
    (let ((a1-1 (new 'stack-no-clear 'event-message-block)))
      (set! (-> a1-1 from) (process->ppointer self))
      (set! (-> a1-1 num-params) 0)
      (set! (-> a1-1 message) 'trigger)
      (let ((t9-2 send-event-function)
            (v1-19 (-> self battle-entity))
            )
        (t9-2
          (if v1-19
              (-> v1-19 extra process)
              )
          a1-1
          )
        )
      )
    (let ((a1-2 (new 'stack-no-clear 'event-message-block)))
      (set! (-> a1-2 from) (process->ppointer self))
      (set! (-> a1-2 num-params) 0)
      (set! (-> a1-2 message) 'turret-activate)
      (let ((t9-3 send-event-function)
            (v1-26 (-> (the-as (array game-task-node-info) (-> *game-info* counter-flash)) 215))
            )
        (t9-3
          (handle->process (if (-> v1-26 manager)
                               (-> v1-26 manager manager)
                               (the-as handle #f)
                               )
                           )
          a1-2
          )
        )
      )
    )
  )

;; failed to figure out what this is:
(defstate gunner-setup (for-turret)
  :virtual override
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('trigger)
       (go-virtual gunner-active)
       )
      (('abort)
       (set! (-> self rider) (the-as handle #f))
       (go-virtual shutdown)
       )
      (else
        (turret-handler proc argc message block)
        )
      )
    )
  :enter (behavior ()
    (set! (-> self enable-controls) #f)
    )
  :trans (behavior ()
    (when (not (handle->process (-> self rider)))
      (set! (-> self rider) (the-as handle #f))
      (go-virtual idle)
      )
    )
  :code sleep-code
  )

;; failed to figure out what this is:
(defstate gunner-active (for-turret)
  :virtual override
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('exit-valid)
       (target-turret-method-46 self (the-as vector (-> block param 0)))
       )
      (('exit)
       (go-virtual shutdown)
       #f
       )
      (('abort)
       (set! (-> self rider) (the-as handle #f))
       (go-virtual shutdown)
       )
      (('set-focus)
       (let ((v0-0 (the-as object (-> block param 0))))
         (set! (-> self focus-handle) (the-as handle v0-0))
         v0-0
         )
       )
      (else
        (turret-handler proc argc message block)
        )
      )
    )
  :enter (behavior ()
    (set! (-> self fire-timer) 0)
    (set! (-> self mode-sound-bank) (add-setting! 'mode-sound-bank 'modegud1 0.0 0))
    (target-turret-method-56 self)
    )
  :exit (behavior ()
    (send-event (handle->process (-> self projectile-handle)) 'die)
    (setting-control-method-14 *setting-control* (-> self mode-sound-bank))
    (set! (-> self projectile-handle) (the-as handle #f))
    )
  :trans (behavior ()
    (if (not (handle->process (-> self rider)))
        (go-virtual shutdown)
        )
    )
  :code (behavior ()
    (until #f
      (let ((v1-2 (- (current-time) (-> self fire-timer))))
        (when (and (-> self projectile-handle) (> v1-2 0) (< v1-2 (seconds 0.5)))
          (send-event (handle->process (-> self projectile-handle)) 'set-damage #x40000000)
          (send-event self 'rider-fire)
          (ja-channel-push! 1 0)
          (ja-no-eval :group! for-turret-shoot-ja :num! (seek!) :frame-num 0.0)
          (until (ja-done? 0)
            (suspend)
            (ja :num! (seek!))
            )
          (suspend-for (-> self params fire-interval)
            )
          )
        )
      (suspend)
      )
    #f
    )
  :post (behavior ()
    (vector<-cspace! (-> self muzzle-pos) (joint-node for-turret-lod0-jg recoil))
    (let ((gp-0 (as-type (handle->process (-> self focus-handle)) process-focusable)))
      (when gp-0
        (let ((s5-1 (new 'stack-no-clear 'vector)))
          (vector-copy! s5-1 (get-trans gp-0 3))
          (when (>= 327680.0 (vector-vector-xz-distance s5-1 (-> self root trans)))
            (let ((s4-0 (new 'stack-no-clear 'vector)))
              (vector-copy! s4-0 (get-transv gp-0))
              (vector+float*! (-> self aim-pos) s5-1 s4-0 -0.3)
              )
            (when (and (time-elapsed? (-> self fire-timer) (-> self params fire-interval))
                       gp-0
                       (not (logtest? (-> (the-as process-focusable gp-0) focus-status) (focus-status disable dead ignore grabbed)))
                       )
              (let* ((s5-3 (vector-! (new 'stack-no-clear 'vector) (-> self aim-pos) (-> self muzzle-pos)))
                     (f30-1 (vector-length s5-3))
                     (gp-1 (new 'stack-no-clear 'vector))
                     )
                (vector-copy! gp-1 (-> self node-list data 6 bone transform fvec))
                (vector-normalize! s5-3 1.0)
                (vector-normalize! gp-1 1.0)
                (if (and (< (acos (vector-dot s5-3 gp-1)) 1820.4445)
                         (>= (+ -819.2 (target-turret-method-47 self (-> self muzzle-pos) gp-1 327680.0)) f30-1)
                         )
                    (set-time! (-> self fire-timer))
                    )
                )
              )
            )
          )
        )
      )
    (let ((gp-3 (vector-! (new 'stack-no-clear 'vector) (-> self aim-pos) (-> self muzzle-pos))))
      (set! (-> gp-3 y) 0.0)
      (vector-xz-normalize! gp-3 1.0)
      (set! (-> self dest-roty) (vector-y-angle gp-3))
      )
    (cond
      ((< (fabs (deg-diff (-> self roty) (-> self dest-roty))) 8192.0)
       (let ((gp-5 (vector-! (new 'stack-no-clear 'vector) (-> self aim-pos) (-> self muzzle-pos))))
         (let ((s5-4 (joint-node for-turret-lod0-jg main)))
           (vector-normalize! gp-5 1.0)
           (vector-flatten! gp-5 gp-5 (-> s5-4 bone transform rvec))
           )
         (set! (-> self dest-rotx) (- (vector-x-angle gp-5)))
         )
       )
      (else
        (set! (-> self dest-rotx) 0.0)
        )
      )
    (target-turret-method-45 self)
    (seek!
      (-> self heat)
      (-> self heat-target)
      (* (fmin 0.5 (fabs (- (-> self heat) (-> self heat-target)))) (seconds-per-frame))
      )
    (seek! (-> self heat-target) 0.0 (* 0.4 (seconds-per-frame)))
    (target-turret-method-43 self)
    (transform-post)
    )
  )

;; failed to figure out what this is:
(defstate active (for-turret)
  :virtual #t
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type target-turret active) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (let ((a1-0 (new 'stack-no-clear 'event-message-block)))
      (set! (-> a1-0 from) (process->ppointer self))
      (set! (-> a1-0 num-params) 0)
      (set! (-> a1-0 message) 'resume)
      (let ((t9-1 send-event-function)
            (v1-6 (-> self battle-entity))
            )
        (t9-1
          (if v1-6
              (-> v1-6 extra process)
              )
          a1-0
          )
        )
      )
    (set! (-> self mode-sound-bank) (add-setting! 'mode-sound-bank 'modegud1 0.0 0))
    (target-turret-method-56 self)
    )
  :exit (behavior ()
    (let ((t9-0 (-> (method-of-type target-turret active) exit)))
      (if t9-0
          (t9-0)
          )
      )
    (send-event (handle->process (-> self projectile-handle)) 'die)
    (setting-control-method-14 *setting-control* (-> self mode-sound-bank))
    (set! (-> self projectile-handle) (the-as handle #f))
    )
  :code (behavior ()
    (until #f
      (when (and (-> self projectile-handle) (not (time-elapsed? (-> self fire-time) (seconds 0.05))))
        (ja-channel-push! 1 (seconds 0.05))
        (ja-no-eval :group! for-turret-shoot-ja :num! (seek!) :frame-num 0.0)
        (until (ja-done? 0)
          (suspend)
          (ja :num! (seek!))
          )
        (suspend-for (-> self params fire-interval)
          )
        )
      (suspend)
      )
    #f
    )
  )

;; failed to figure out what this is:
(defstate shutdown (for-turret)
  :virtual #t
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type target-turret shutdown) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (set! (-> self dest-roty) (-> self roty))
    (let ((a1-0 (new 'stack-no-clear 'event-message-block)))
      (set! (-> a1-0 from) (process->ppointer self))
      (set! (-> a1-0 num-params) 0)
      (set! (-> a1-0 message) 'beaten)
      (let ((t9-1 send-event-function)
            (v1-6 (-> self battle-entity))
            )
        (t9-1
          (if v1-6
              (-> v1-6 extra process)
              )
          a1-0
          )
        )
      )
    )
  )

;; definition for method 56 of type for-turret
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defmethod target-turret-method-56 ((this for-turret))
  (let* ((s5-0 (-> this node-list data 6))
         (s4-0 (vector<-cspace! (new 'stack-no-clear 'vector) s5-0))
         )
    (vector-copy! (new 'stack-no-clear 'vector) s4-0)
    (let ((s3-0 (new 'stack-no-clear 'vector)))
      (vector-copy! s3-0 (-> s5-0 bone transform fvec))
      (let ((s5-1 (new 'stack-no-clear 'projectile-init-by-other-params)))
        (vector-normalize! s3-0 1.0)
        (vector+float*! s4-0 s4-0 s3-0 10240.0)
        (set! (-> s5-1 ent) (-> this entity))
        (set! (-> s5-1 charge) 1.0)
        (set! (-> s5-1 options) (projectile-options))
        (vector-copy! (-> s5-1 pos) s4-0)
        (vector-copy! (-> s5-1 vel) s3-0)
        (set! (-> s5-1 notify-handle) (process->handle this))
        (set! (-> s5-1 owner-handle) (the-as handle #f))
        (set! (-> s5-1 target-handle) (the-as handle #f))
        (set! (-> s5-1 target-pos quad) (the-as uint128 0))
        (set! (-> s5-1 ignore-handle) (process->handle this))
        (let* ((v1-18 *game-info*)
               (a0-17 (+ (-> v1-18 attack-ids) 1))
               )
          (set! (-> v1-18 attack-ids) a0-17)
          (set! (-> s5-1 attack-id) a0-17)
          )
        (set! (-> s5-1 timeout) (seconds 4))
        (set! (-> this projectile-handle)
              (process->handle (ppointer->process (spawn-projectile for-turret-shot s5-1 this *default-dead-pool*)))
              )
        )
      )
    )
  0
  (none)
  )

;; definition for method 39 of type for-turret
;; WARN: Return type mismatch int vs none.
(defmethod target-turret-method-39 ((this for-turret))
  (set! (-> this hud)
        (ppointer->handle
          (process-spawn hud-for-turret-health :init hud-init-by-other :name "hud-for-turret-health" :to this)
          )
        )
  (set! (-> this hud-arrows)
        (ppointer->handle
          (process-spawn hud-for-turret-arrows :init hud-init-by-other :name "hud-for-turret-arrows" :to this)
          )
        )
  0
  (none)
  )

;; definition for method 57 of type for-turret
(defmethod target-turret-method-57 ((this for-turret))
  (send-event (handle->process (-> this hud-arrows)) 'hide-and-die)
  ((method-of-type target-turret target-turret-method-57) this)
  (none)
  )

;; definition for method 52 of type for-turret
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
;; ERROR: Expression building failed: In (method 52 for-turret): At op 5, used int to float on a float from f0-1: (/ (-> this health) (-> this params max-health))
;; ERROR: Unsupported inline assembly instruction kind - [sllv a0, v1, r0]
;; ERROR: Unsupported inline assembly instruction kind - [sllv a0, v1, r0]
;; ERROR: Unsupported inline assembly instruction kind - [sllv a0, v1, r0]
;; ERROR: Unsupported inline assembly instruction kind - [sllv a0, v1, r0]
;; ERROR: Unsupported inline assembly instruction kind - [sllv a0, v1, r0]
;; ERROR: Unsupported inline assembly instruction kind - [sllv a0, v1, r0]
;; ERROR: Unsupported inline assembly instruction kind - [sllv a0, v1, r0]
(defmethod target-turret-method-52 ((this for-turret))
  (local-vars
    (v0-0 object)
    (v0-1 object)
    (v0-2 object)
    (v0-3 int)
    (v0-4 symbol)
    (v0-5 symbol)
    (v0-6 none)
    (v0-7 vector)
    (v0-8 symbol)
    (v0-9 matrix)
    (v0-10 matrix)
    (v0-11 object)
    (v0-12 object)
    (v0-13 object)
    (v0-14 object)
    (v0-15 int)
    (v1-0 target-turret-params)
    (v1-1 game-info)
    (v1-2 process)
    (v1-3 symbol)
    (v1-4 handle)
    (v1-5 int)
    (v1-8 process)
    (v1-9 symbol)
    (v1-10 handle)
    (v1-11 int)
    (v1-14 process)
    (v1-15 symbol)
    (v1-16 handle)
    (v1-17 int)
    (v1-20 collide-shape)
    (v1-21 vector)
    (v1-22 uint128)
    (v1-23 float)
    (v1-24 vector)
    (v1-25 type)
    (v1-26 vector)
    (v1-27 int)
    (v1-28 object)
    (v1-29 object)
    (v1-30 int)
    (v1-31 process-mask)
    (v1-32 focus-status)
    (v1-33 focus-status)
    (v1-34 focus-status)
    (v1-35 focus-status)
    (v1-36 target)
    (v1-37 type)
    (v1-38 type)
    (v1-39 float)
    (v1-40 vector)
    (v1-41 vector)
    (v1-42 float)
    (v1-43 process)
    (v1-44 symbol)
    (v1-45 handle)
    (v1-46 int)
    (v1-48 process)
    (v1-49 symbol)
    (v1-50 handle)
    (v1-51 int)
    (v1-53 float)
    (v1-55 process)
    (v1-56 symbol)
    (v1-57 handle)
    (v1-58 int)
    (v1-60 float)
    (v1-61 process)
    (v1-62 symbol)
    (v1-63 handle)
    (v1-64 int)
    (a0-1 (pointer process))
    (a0-2 int)
    (a0-3 process)
    (a0-4 (pointer process))
    (a0-5 int)
    (a0-6 (pointer process))
    (a0-7 int)
    (a0-8 process)
    (a0-9 (pointer process))
    (a0-10 int)
    (a0-11 (pointer process))
    (a0-12 int)
    (a0-13 process)
    (a0-14 (pointer process))
    (a0-15 int)
    (a0-16 vector)
    (a0-17 vector)
    (a0-18 vector)
    (a0-19 spatial-hash)
    (a0-20 int)
    (a0-21 float)
    (a0-23 joint-control)
    (a0-24 process-mask)
    (a0-25 symbol)
    (a0-26 symbol)
    (a0-27 for-turret)
    (a0-29 joint-control)
    (a0-30 vector)
    (a0-31 (pointer process))
    (a0-32 int)
    (a0-33 process)
    (a0-34 (pointer process))
    (a0-35 int)
    (a0-37 (pointer process))
    (a0-38 int)
    (a0-39 process)
    (a0-40 (pointer process))
    (a0-41 int)
    (a0-43 (pointer process))
    (a0-44 int)
    (a0-45 process)
    (a0-46 (pointer process))
    (a0-47 int)
    (a0-50 (pointer process))
    (a0-51 int)
    (a0-52 process)
    (a0-53 (pointer process))
    (a0-54 int)
    (a1-0 event-message-block)
    (a1-1 event-message-block)
    (a1-2 event-message-block)
    (a1-3 vector)
    (a1-4 type)
    (a1-5 type)
    (a1-6 joint-control)
    (a1-7 int)
    (a1-8 vector)
    (a1-9 event-message-block)
    (a1-10 event-message-block)
    (a1-11 event-message-block)
    (a1-12 event-message-block)
    (a2-0 process)
    (a2-1 process)
    (a2-2 process)
    (a2-3 structure)
    (a3-0 int)
    (s3-0 joint-control)
    (s3-1 vector)
    (s3-2 vector)
    (s3-3 vector)
    (s4-0 float)
    (s4-1 basic)
    (s4-2 vector)
    (s5-0 int)
    (t9-0 (function process-tree event-message-block object))
    (t9-1 (function process-tree event-message-block object))
    (t9-2 (function process-tree event-message-block object))
    (t9-3 (function spatial-hash vector (pointer collide-shape) int int))
    (t9-4 (function object type symbol))
    (t9-5 (function object type symbol))
    (t9-6 (function for-turret vector vector none))
    (t9-7 (function process-focusable int vector))
    (t9-8 (function vector vector symbol))
    (t9-9 (function matrix))
    (t9-10 (function matrix))
    (t9-11 (function process-tree event-message-block object))
    (t9-12 (function process-tree event-message-block object))
    (t9-13 (function process-tree event-message-block object))
    (t9-14 (function process-tree event-message-block object))
    (f0-0 float)
    (f0-1 float)
    (f0-2 float)
    (f0-3 float)
    (f0-4 float)
    (f0-5 float)
    (f0-6 float)
    (f0-7 float)
    (f0-8 float)
    (f0-9 float)
    (f0-10 float)
    (f1-0 float)
    (f1-1 float)
    (f1-2 float)
    (f1-3 float)
    (f1-4 float)
    (f30-0 float)
    (sv-240 vector)
    (sv-244 vector)
    )
  (with-pp
    (if (begin
          (if (begin
                (and (begin
                       (if (begin
                             (set! f0-0 (-> this health))
                             (set! v1-0 (-> this params))
                             (set! f1-0 (-> this params max-health))
                             (set! f0-1 (/ (-> this health) (-> this params max-health)))
                             (set! f0-2 (i2f f0-1))
                             (set! v1-1 *game-info*)
                             (s.f! (+ v1-1 656) f0-2)
                             (set! a1-0 (new 'stack-no-clear 'event-message-block))
                             (set! v1-2 pp)
                             v1-2
                             )
                           (set! a0-1 (-> v1-2 ppointer))
                           )
                       (set! (-> a1-0 from) a0-1)
                       (set! (-> a1-0 num-params) 0)
                       (set! v1-3 'force-show)
                       (set! (-> a1-0 message) v1-3)
                       (set! t9-0 send-event-function)
                       (set! v1-4 (-> this hud))
                       (set! a0-2 (subu-s7 v1-4))
                       (nonzero? a0-2)
                       )
                     (begin
                       (if (begin
                             (.sllv a0-4 v1-4 r0)
                             (set! a2-0 (-> a0-4 0))
                             (set! a0-5 (-> a2-0 pid))
                             (set! v1-5 (sra v1-4 32))
                             (= v1-5 a0-5)
                             )
                           (set! a0-3 a2-0)
                           )
                       (set! v1-6 a0-3)
                       )
                     )
                (call! a0-3 a1-0)
                (set! v1-7 v0-0)
                (set! a1-1 (new 'stack-no-clear 'event-message-block))
                (set! v1-8 pp)
                v1-8
                )
              (set! a0-6 (-> v1-8 ppointer))
              )
          (and (begin
                 (set! (-> a1-1 from) a0-6)
                 (set! (-> a1-1 num-params) 0)
                 (set! v1-9 'force-show)
                 (set! (-> a1-1 message) v1-9)
                 (set! t9-1 send-event-function)
                 (set! v1-10 (-> this hud-arrows))
                 (set! a0-7 (subu-s7 v1-10))
                 (nonzero? a0-7)
                 )
               (begin
                 (if (begin
                       (.sllv a0-9 v1-10 r0)
                       (set! a2-1 (-> a0-9 0))
                       (set! a0-10 (-> a2-1 pid))
                       (set! v1-11 (sra v1-10 32))
                       (= v1-11 a0-10)
                       )
                     (set! a0-8 a2-1)
                     )
                 (set! v1-12 a0-8)
                 )
               )
          (call! a0-8 a1-1)
          (set! v1-13 v0-1)
          (set! a1-2 (new 'stack-no-clear 'event-message-block))
          (set! v1-14 pp)
          v1-14
          )
        (set! a0-11 (-> v1-14 ppointer))
        )
    (and (begin
           (set! (-> a1-2 from) a0-11)
           (set! (-> a1-2 num-params) 0)
           (set! v1-15 'reset-arrows)
           (set! (-> a1-2 message) v1-15)
           (set! t9-2 send-event-function)
           (set! v1-16 (-> this hud-arrows))
           (set! a0-12 (subu-s7 v1-16))
           (nonzero? a0-12)
           )
         (begin
           (if (begin
                 (.sllv a0-14 v1-16 r0)
                 (set! a2-2 (-> a0-14 0))
                 (set! a0-15 (-> a2-2 pid))
                 (set! v1-17 (sra v1-16 32))
                 (= v1-17 a0-15)
                 )
               (set! a0-13 a2-2)
               )
           (set! v1-18 a0-13)
           )
         )
    (call! a0-13 a1-2)
    (set! v1-19 v0-2)
    (set! v1-20 (-> this root))
    (set! v1-21 (-> v1-20 trans))
    (set! a0-16 (new 'stack-no-clear 'vector))
    (set! sv-240 a0-16)
    (set! a0-17 (new 'stack-no-clear 'vector))
    (set! sv-244 a0-17)
    (set! a0-18 sv-244)
    (set! v1-22 (-> v1-21 quad))
    (set! (-> a0-18 quad) v1-22)
    (set! v1-23 163840.0)
    (set! f0-3 (gpr->fpr v1-23))
    (set! v1-24 sv-244)
    (set! (-> v1-24 w) f0-3)
    (set! a0-19 *actor-hash*)
    (set! v1-25 (-> a0-19 type))
    (set! t9-3 (method-of-type v1-25 fill-actor-list-for-box))
    (set! a1-3 sv-244)
    (set! a2-3 sv-240)
    (set! a3-0 32)
    (set! v0-3 (call! a0-19 a1-3 (the-as vector a2-3) a3-0))
    (set! s5-0 v0-3)
    (while (nonzero? s5-0)
      (when (begin
              (if (begin
                    (set! s5-0 (+ s5-0 -1))
                    (set! v1-26 sv-240)
                    (set! a0-20 (sll s5-0 2))
                    (set! v1-27 (+ v1-26 a0-20))
                    (set! s4-0 (dynamic-array-field-access v1-27 data PLACEHOLDER))
                    (set! t9-4 type?)
                    (set! a0-21 s4-0)
                    (set! a1-4 collide-shape)
                    (set! v0-4 (call! a0-21 a1-4))
                    v0-4
                    )
                  (set! v1-28 s4-0)
                  )
              (the-as float v1-28)
              )
        (when (begin
                (if (begin
                      (set! s3-0 (-> (the-as for-turret v1-28) skel))
                      (set! t9-5 type?)
                      (set! a0-23 s3-0)
                      (set! a1-5 process-focusable)
                      (set! v0-5 (call! a0-23 a1-5))
                      v0-5
                      )
                    (set! s4-1 s3-0)
                    )
                (and (the-as joint-control s4-1)
                     (begin
                       (set! v1-30 #x80000)
                       (set! a0-24 (-> (the-as process-focusable s4-1) mask))
                       (set! v1-31 (logand v1-30 a0-24))
                       (nonzero? v1-31)
                       )
                     (begin
                       (set! v1-32 (-> (the-as process-focusable s4-1) focus-status))
                       (set! v1-33 (logand v1-32 16))
                       (nonzero? v1-33)
                       )
                     (begin
                       (set! v1-34 (-> (the-as process-focusable s4-1) focus-status))
                       (set! v1-35 (logand v1-34 15))
                       (zero? v1-35)
                       )
                     (begin (set! a0-25 (!= (the-as joint-control s4-1) this)) a0-25)
                     (begin (set! v1-36 *target*) (set! a0-26 (!= (the-as joint-control s4-1) v1-36)) a0-26)
                     (begin
                       (set! a0-27 this)
                       (set! v1-37 (-> a0-27 type))
                       (set! t9-6 (method-of-type v1-37 target-turret-method-51))
                       (set! a1-6 (the-as joint-control s4-1))
                       (set! v0-6 (call! a0-27 a1-6 (the-as none a2-3)))
                       (set! v1-29 v0-6)
                       )
                     )
                v1-29
                )
          (cond
            ((begin
               (set! s3-1 (new 'stack-no-clear 'vector))
               (set! v1-38 (-> (the-as process-focusable s4-1) type))
               (set! t9-7 (method-of-type v1-38 get-trans))
               (set! a1-7 0)
               (set! a0-29 (the-as joint-control s4-1))
               (set! v0-7 (call! a0-29 a1-7))
               (set! s4-2 v0-7)
               (set! t9-8 transform-point-vector!)
               (set! a0-30 s3-1)
               (set! a1-8 s4-2)
               (call! a0-30 a1-8)
               (set! v1-39 -2048.0)
               (set! f0-4 (gpr->fpr v1-39))
               (set! f1-1 (-> s3-1 x))
               (set! f0-5 (+.s f0-4 f1-1))
               (set! (-> s3-1 x) f0-5)
               (set! f0-6 (-> s3-1 z))
               (set! f1-2 0.0)
               (<.s f0-6 f1-2)
               )
             (cond
               ((begin
                  (set! s3-2 (new 'stack-no-clear 'vector))
                  (set! t9-9 camera-matrix)
                  (set! v0-9 (call!))
                  (set! v1-40 (-> v0-9 trans))
                  (set! s3-3 (vector-!2 s3-2 s4-2 v1-40))
                  (set! f30-0 0.0)
                  (set! t9-10 camera-matrix)
                  (set! v0-10 (call!))
                  (set! v1-41 (-> v0-10 rvec))
                  (set! f0-7 (vec3dot s3-3 v1-41))
                  (set! v1-42 (fpr->gpr f0-7))
                  (set! f0-8 (gpr->fpr v1-42))
                  (<.s f30-0 f0-8)
                  )
                (and (begin
                       (if (begin (set! a1-9 (new 'stack-no-clear 'event-message-block)) (set! v1-43 pp) v1-43)
                           (set! a0-31 (-> v1-43 ppointer))
                           )
                       (set! (-> a1-9 from) a0-31)
                       (set! (-> a1-9 num-params) 0)
                       (set! v1-44 'off-to-left)
                       (set! (-> a1-9 message) v1-44)
                       (set! t9-11 send-event-function)
                       (set! v1-45 (-> this hud-arrows))
                       (set! a0-32 (subu-s7 v1-45))
                       (nonzero? a0-32)
                       )
                     (begin
                       (if (begin
                             (.sllv a0-34 v1-45 r0)
                             (set! a2-3 (-> a0-34 0))
                             (set! a0-35 (-> (the-as process a2-3) pid))
                             (set! v1-46 (sra v1-45 32))
                             (= v1-46 a0-35)
                             )
                           (set! a0-33 (the-as process a2-3))
                           )
                       (set! v1-47 a0-33)
                       )
                     )
                (call! a0-33 a1-9)
                (set! a0-36 v0-11)
                )
               (else
                 (and (begin
                        (if (begin (set! a1-10 (new 'stack-no-clear 'event-message-block)) (set! v1-48 pp) v1-48)
                            (set! a0-37 (-> v1-48 ppointer))
                            )
                        (set! (-> a1-10 from) a0-37)
                        (set! (-> a1-10 num-params) 0)
                        (set! v1-49 'off-to-right)
                        (set! (-> a1-10 message) v1-49)
                        (set! t9-12 send-event-function)
                        (set! v1-50 (-> this hud-arrows))
                        (set! a0-38 (subu-s7 v1-50))
                        (nonzero? a0-38)
                        )
                      (begin
                        (if (begin
                              (.sllv a0-40 v1-50 r0)
                              (set! a2-3 (-> a0-40 0))
                              (set! a0-41 (-> (the-as process a2-3) pid))
                              (set! v1-51 (sra v1-50 32))
                              (= v1-51 a0-41)
                              )
                            (set! a0-39 (the-as process a2-3))
                            )
                        (set! v1-52 a0-39)
                        )
                      )
                 (call! a0-39 a1-10)
                 (set! a0-42 v0-12)
                 )
               )
             )
            (else
              (cond
                ((begin (set! f0-9 (-> s3-1 x)) (set! v1-53 -248.0) (set! f1-3 (gpr->fpr v1-53)) (<.s f0-9 f1-3))
                 (and (begin
                        (if (begin (set! a1-11 (new 'stack-no-clear 'event-message-block)) (set! v1-55 pp) v1-55)
                            (set! a0-43 (-> v1-55 ppointer))
                            )
                        (set! (-> a1-11 from) a0-43)
                        (set! (-> a1-11 num-params) 0)
                        (set! v1-56 'off-to-left)
                        (set! (-> a1-11 message) v1-56)
                        (set! t9-13 send-event-function)
                        (set! v1-57 (-> this hud-arrows))
                        (set! a0-44 (subu-s7 v1-57))
                        (nonzero? a0-44)
                        )
                      (begin
                        (if (begin
                              (.sllv a0-46 v1-57 r0)
                              (set! a2-3 (-> a0-46 0))
                              (set! a0-47 (-> (the-as process a2-3) pid))
                              (set! v1-58 (sra v1-57 32))
                              (= v1-58 a0-47)
                              )
                            (set! a0-45 (the-as process a2-3))
                            )
                        (set! v1-59 a0-45)
                        )
                      )
                 (call! a0-45 a1-11)
                 (set! a0-48 v0-13)
                 )
                ((begin (set! v1-60 264.0) (set! f0-10 (gpr->fpr v1-60)) (set! f1-4 (-> s3-1 x)) (<.s f0-10 f1-4))
                 (and (begin
                        (if (begin (set! a1-12 (new 'stack-no-clear 'event-message-block)) (set! v1-61 pp) v1-61)
                            (set! a0-50 (-> v1-61 ppointer))
                            )
                        (set! (-> a1-12 from) a0-50)
                        (set! (-> a1-12 num-params) 0)
                        (set! v1-62 'off-to-right)
                        (set! (-> a1-12 message) v1-62)
                        (set! t9-14 send-event-function)
                        (set! v1-63 (-> this hud-arrows))
                        (set! a0-51 (subu-s7 v1-63))
                        (nonzero? a0-51)
                        )
                      (begin
                        (if (begin
                              (.sllv a0-53 v1-63 r0)
                              (set! a2-3 (-> a0-53 0))
                              (set! a0-54 (-> (the-as process a2-3) pid))
                              (set! v1-64 (sra v1-63 32))
                              (= v1-64 a0-54)
                              )
                            (set! a0-52 (the-as process a2-3))
                            )
                        (set! v1-65 a0-52)
                        )
                      )
                 (call! a0-52 a1-12)
                 (set! a0-55 v0-14)
                 )
                )
              )
            )
          )
        )
      )
    (set! v0-15 0)
    (ret-none)
    )
  )

;; definition for method 40 of type for-turret
;; ERROR: function was not converted to expressions. Cannot decompile.

;; definition for symbol *for-turret-offset-table*, type (array vector)
(define *for-turret-offset-table* <static-data L220>)

;; definition for method 46 of type for-turret
;; INFO: Used lq/sq
(defmethod target-turret-method-46 ((this for-turret) (arg0 vector))
  (let ((s4-0 (vector<-cspace! (new 'stack-no-clear 'vector) (-> this node-list data 10))))
    (set! (-> s4-0 y) (+ 409.6 (-> this root trans y)))
    (dotimes (s3-0 (-> *for-turret-offset-table* length))
      (let* ((a0-3
               (vector-rotate-around-y! (new 'stack-no-clear 'vector) (-> *for-turret-offset-table* s3-0) (-> this roty))
               )
             (s2-1 (vector+! (new 'stack-no-clear 'vector) s4-0 a0-3))
             (f30-0 6144.0)
             )
        (add-debug-sphere #t (bucket-id hud-draw-pris2) s2-1 f30-0 *color-white*)
        (let ((a1-5 (new 'stack-no-clear 'collide-query)))
          (vector-copy! (-> a1-5 start-pos) s2-1)
          (+! (-> a1-5 start-pos y) 12288.0)
          (set-vector! (-> a1-5 move-dist) 0.0 -12288.0 0.0 0.0)
          (let ((v1-10 a1-5))
            (set! (-> v1-10 radius) f30-0)
            (set! (-> v1-10 collide-with)
                  (collide-spec
                    crate
                    enemy
                    obstacle
                    vehicle-sphere
                    hit-by-player-list
                    hit-by-others-list
                    pusher
                    obstacle-for-jak
                    )
                  )
            (set! (-> v1-10 ignore-process0) #f)
            (set! (-> v1-10 ignore-process1) #f)
            (set! (-> v1-10 ignore-pat)
                  (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
                  )
            (set! (-> v1-10 action-mask) (collide-action solid))
            )
          (when (< (fill-and-probe-using-line-sphere *collide-cache* a1-5) 0.0)
            (vector-copy! arg0 s2-1)
            (return #t)
            )
          )
        )
      )
    )
  #f
  )

;; definition for method 44 of type for-turret
;; WARN: Return type mismatch int vs none.
(defmethod target-turret-method-44 ((this for-turret) (arg0 float))
  0
  (none)
  )

;; definition for method 50 of type for-turret
;; WARN: Return type mismatch int vs none.
(defmethod target-turret-method-50 ((this for-turret))
  (when (and (-> this projectile-handle) (< (-> this heat) 1.0))
    (let ((t9-0 (method-of-type target-turret target-turret-method-50)))
      (t9-0 this)
      )
    (let ((a0-3 (handle->process (-> this projectile-handle))))
      (if (and a0-3 (send-event a0-3 'trigger))
          (target-turret-method-56 this)
          )
      )
    (activate! (-> this smush-control) 0.1 30 120 0.8 0.9 (-> *display* entity-clock))
    )
  0
  (none)
  )

;; definition for method 53 of type for-turret
;; INFO: Used lq/sq
(defmethod target-turret-method-53 ((this for-turret) (arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (local-vars (s5-1 object))
  (let ((v1-0 arg2))
    (set! s5-1 (cond
                 ((= v1-0 'turret-type)
                  'for-turret
                  )
                 ((= v1-0 'camera-offset)
                  (set! s5-1 (-> arg3 param 0))
                  (set! (-> (the-as vector s5-1) x) 0.0)
                  (set! (-> (the-as vector s5-1) y) 4096.0)
                  (set! (-> (the-as vector s5-1) z) (lerp-scale -12288.0 -4096.0 (-> this rotx) 0.0 -6371.5557))
                  (set! (-> (the-as vector s5-1) w) 0.0)
                  s5-1
                  )
                 ((= v1-0 'notify)
                  (case (-> arg3 param 0)
                    (('attack)
                     (when (= (-> arg3 param 1) *target*)
                       (set! s5-1 (+ (-> this fire-timer) (seconds 3)))
                       (set! (-> this fire-timer) (the-as time-frame s5-1))
                       s5-1
                       )
                     )
                    (('die)
                     (when (= arg0 (handle->process (-> this projectile-handle)))
                       (set! (-> this projectile-handle) (the-as handle #f))
                       #f
                       )
                     )
                    )
                  )
                 ((= v1-0 'shot-pos)
                  (let* ((s3-0 (-> this node-list data 6))
                         (gp-1 (vector<-cspace! (new 'stack-no-clear 'vector) s3-0))
                         )
                    (let ((s4-0 (new 'stack-no-clear 'vector)))
                      (vector-copy! s4-0 (-> s3-0 bone transform fvec))
                      (vector-normalize! s4-0 1.0)
                      (vector+float*! gp-1 gp-1 s4-0 10240.0)
                      )
                    (set! s5-1 (-> arg3 param 0))
                    (set! (-> (the-as vector s5-1) quad) (-> gp-1 quad))
                    )
                  s5-1
                  )
                 ((= v1-0 'valid-neo-spawner)
                  (let ((v1-15 (command-get-entity arg0 (the-as entity #f))))
                    (dotimes (a0-19 (-> this actor-group 0 length))
                      (when (= v1-15 (-> this actor-group 0 data a0-19 actor))
                        (set! s5-1 #t)
                        (goto cfg-51)
                        )
                      )
                    )
                  #f
                  )
                 ((= v1-0 'player-pos)
                  (vector<-cspace! (the-as vector (-> arg3 param 0)) (-> this node-list data 10))
                  )
                 ((= v1-0 'player-quat)
                  (matrix->quat (-> this node-list data 10 bone transform) (the-as quaternion (-> arg3 param 0)))
                  )
                 ((= v1-0 'gunner-pos)
                  (vector<-cspace! (the-as vector (-> arg3 param 0)) (-> this node-list data 11))
                  )
                 ((= v1-0 'gunner-quat)
                  (matrix->quat (-> this node-list data 11 bone transform) (the-as quaternion (-> arg3 param 0)))
                  )
                 ((= v1-0 'sideways)
                  (lerp-scale -1.0 1.0 (-> this rotyv) (- (-> this params rotyv-max)) (-> this params rotyv-max))
                  )
                 ((or (= v1-0 'fire-up) (= v1-0 'fire-down))
                  #f
                  )
                 ((or (= v1-0 'rider-fire) (= v1-0 'fire-pressed))
                  (if (time-elapsed? (-> this fire-time) (-> this fire-time-interval))
                      (target-turret-method-50 this)
                      )
                  )
                 (else
                   ((method-of-type target-turret target-turret-method-53) this arg0 arg1 arg2 arg3)
                   )
                 )
          )
    )
  (label cfg-51)
  s5-1
  )

;; definition for method 34 of type for-turret
;; WARN: Return type mismatch int vs none.
(defmethod init! ((this for-turret))
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-for-turret" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (set! (-> this info) (new 'static 'target-turret-info :idle-anim 4 :camera-joint 13))
  (set! (-> this info explode-sg)
        (the-as skeleton-group (art-group-get-by-name *level* "skel-for-turret-explode" (the-as (pointer level) #f)))
        )
  (set! (-> this info explode-params) (the-as explosion-init-params *for-turret-exploder-params*))
  0
  (none)
  )

;; definition for method 38 of type for-turret
(defmethod get-params ((this for-turret))
  *for-turret-params*
  )

;; definition for method 36 of type for-turret
;; INFO: Used lq/sq
;; WARN: Return type mismatch int vs none.
(defmethod init-fields! ((this for-turret))
  (local-vars (r0-0 uint128) (v1-3 uint128) (a0-2 object) (a1-2 uint128) (sv-16 int))
  (set! (-> this focus-handle) (the-as handle #f))
  (set! (-> this projectile-handle) (the-as handle #f))
  (set! sv-16 0)
  (let ((v1-1 (res-lump-data (-> this entity) 'actor-groups pointer :tag-ptr (the-as (pointer res-tag) (& sv-16)))))
    (cond
      ((and v1-1 (begin
                   (let ((a0-3 #t))
                     (let ((a1-1 (the-as uint128 sv-16)))
                       (.pcpyud a1-2 a1-1 r0-0)
                       )
                     (let ((a1-4 (the-as int (shr (* (the-as int a1-2) 2) 49))))
                       (cmove-#f-zero a0-2 a1-4 a0-3)
                       )
                     )
                   a0-2
                   )
            )
       (set! (-> this actor-group) (the-as (pointer actor-group) v1-1))
       (let ((v1-2 (the-as uint128 sv-16)))
         (.pcpyud v1-3 v1-2 r0-0)
         )
       (set! (-> this actor-group-count) (shr (* (the-as int v1-3) 2) 49))
       )
      (else
        (set! (-> this actor-group) (the-as (pointer actor-group) #f))
        (set! (-> this actor-group-count) 0)
        0
        )
      )
    )
  (let ((a0-4 (-> this node-list data 3)))
    (set! (-> a0-4 param0)
          (lambda ((arg0 cspace) (arg1 transformq))
            (let ((v1-0 (-> arg0 param1)))
              (quaternion-vector-angle! (-> arg1 quat) *y-vector* (-> (the-as for-turret v1-0) roty))
              )
            (cspace<-parented-transformq-joint! arg0 arg1)
            (none)
            )
          )
    (set! (-> a0-4 param1) this)
    )
  (let ((a0-5 (-> this node-list data 4)))
    (set! (-> a0-5 param0)
          (lambda ((arg0 cspace) (arg1 transformq))
            (let ((v1-0 (-> arg0 param1)))
              (quaternion-vector-angle! (-> arg1 quat) *x-vector* (-> (the-as for-turret v1-0) rotx))
              )
            (cspace<-parented-transformq-joint! arg0 arg1)
            (none)
            )
          )
    (set! (-> a0-5 param1) this)
    )
  (let ((a0-6 (-> this node-list data 9)))
    (set! (-> a0-6 param0) (lambda ((arg0 cspace) (arg1 transformq))
                             (let* ((v1-0 (-> arg0 param1))
                                    (f0-4 (lerp-scale
                                            5461.3335
                                            -5461.3335
                                            (-> (the-as for-turret v1-0) rotyv)
                                            (- (-> (the-as for-turret v1-0) params rotyv-max))
                                            (-> (the-as for-turret v1-0) params rotyv-max)
                                            )
                                          )
                                    )
                               (quaternion-rotate-z! (-> arg1 quat) (-> arg1 quat) f0-4)
                               )
                             (cspace<-parented-transformq-joint! arg0 arg1)
                             (none)
                             )
          )
    (set! (-> a0-6 param1) this)
    )
  (let ((s5-0 (get-process *default-dead-pool* for-turret-blocker #x4000 1)))
    (process->handle
      (ppointer->process
        (when s5-0
          (let ((t9-2 (method-of-type for-turret-blocker activate))
                (a0-8 s5-0)
                (a1-6 this)
                (a2-2 "for-turret-blocker")
                (a3-2 #x70004000)
                )
            (t9-2 (the-as for-turret-blocker a0-8) a1-6 a2-2 (the-as pointer a3-2))
            (run-now-in-process s5-0 for-turret-blocker-init-by-other (-> this root trans) (the-as none a3-2))
            )
          (-> s5-0 ppointer)
          )
        )
      )
    )
  (set! (-> this nav-mesh) (nav-mesh-from-res-tag (-> this entity) 'nav-mesh-actor 0))
  (if (not (-> this nav-mesh))
      (go process-drawable-art-error "no nav-mesh")
      )
  (set! (-> this battle-entity) (entity-actor-lookup (-> this entity) 'alt-actor 1))
  0
  (none)
  )




