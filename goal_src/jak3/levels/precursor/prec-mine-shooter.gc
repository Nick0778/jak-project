;;-*-Lisp-*-
(in-package goal)

(deftype prec-mine-shooter-reticle-info (structure)
  ((reticle             sparticle-launch-control)
   (reticle-corner-0    sparticle-launch-control)
   (reticle-corner-1    sparticle-launch-control)
   (reticle-corner-2    sparticle-launch-control)
   (reticle-corner-3    sparticle-launch-control)
   (reticle-dot         sparticle-launch-control)
   (reticle-arrow       sparticle-launch-control)
   (reticle-super       sparticle-launch-control)
   (reticle-super-ring  sparticle-launch-control)
   (lock-time           time-frame)
   )
  (:methods
    (init! (_type_ process) none)
    (prec-mine-shooter-reticle-info-method-10 (_type_ vector vector int int) none)
    (prec-mine-shooter-reticle-info-method-11 (_type_) none)
    )
  )


(defmethod init! ((this prec-mine-shooter-reticle-info) (arg0 process))
  (set! (-> this reticle) (create-launch-control (-> *part-group-id-table* 1371) arg0))
  (set! (-> this reticle-corner-0) (create-launch-control (-> *part-group-id-table* 1372) arg0))
  (set! (-> this reticle-corner-1) (create-launch-control (-> *part-group-id-table* 1372) arg0))
  (set! (-> this reticle-corner-2) (create-launch-control (-> *part-group-id-table* 1372) arg0))
  (set! (-> this reticle-corner-3) (create-launch-control (-> *part-group-id-table* 1372) arg0))
  (set! (-> this reticle-dot) (create-launch-control (-> *part-group-id-table* 1373) arg0))
  (set! (-> this reticle-arrow) (create-launch-control (-> *part-group-id-table* 1374) arg0))
  (set! (-> this reticle-super) (create-launch-control (-> *part-group-id-table* 1375) arg0))
  (set! (-> this reticle-super-ring) (create-launch-control (-> *part-group-id-table* 1376) arg0))
  (set! (-> this lock-time) 0)
  0
  (none)
  )

(defmethod prec-mine-shooter-reticle-info-method-10 ((this prec-mine-shooter-reticle-info) (arg0 vector) (arg1 vector) (arg2 int) (arg3 int))
  (local-vars (sv-160 vector))
  (set! sv-160 arg0)
  (let ((s4-0 arg1)
        (s2-0 arg2)
        (s1-0 arg3)
        )
    (cond
      ((zero? s2-0)
       (if (zero? (-> this lock-time))
           (set-time! (-> this lock-time))
           )
       )
      (else
        (set! (-> this lock-time) 0)
        0
        )
      )
    (let ((s5-0 (new 'stack-no-clear 'matrix)))
      (let ((s0-0 (or (nonzero? (-> this lock-time)) (< 24 (mod s2-0 48))))
            (s3-0 #t)
            )
        (let ((f28-0 0.0)
              (f30-0 0.0)
              )
          (matrix-identity! s5-0)
          (set! (-> s5-0 trans quad) (-> sv-160 quad))
          (let ((v1-8 s1-0))
            (cond
              ((zero? v1-8)
               (if (zero? s2-0)
                   (set! f28-0 128.0)
                   (set! f30-0 128.0)
                   )
               )
              ((= v1-8 2)
               (cond
                 ((zero? s2-0)
                  (set! f28-0 128.0)
                  )
                 (else
                   (set! f28-0 128.0)
                   (set! f30-0 128.0)
                   )
                 )
               )
              ((zero? s2-0)
               (set! f28-0 128.0)
               )
              (else
                (set! f30-0 128.0)
                )
              )
            )
          (set! (-> *part-id-table* 4568 init-specs 5 initial-valuef) f28-0)
          (set! (-> *part-id-table* 4568 init-specs 6 initial-valuef) f30-0)
          (set! (-> *part-id-table* 4569 init-specs 5 initial-valuef) f28-0)
          (set! (-> *part-id-table* 4569 init-specs 6 initial-valuef) f30-0)
          (set! (-> *part-id-table* 4566 init-specs 5 initial-valuef) f28-0)
          (set! (-> *part-id-table* 4566 init-specs 6 initial-valuef) f30-0)
          (set! (-> *part-id-table* 4567 init-specs 5 initial-valuef) f28-0)
          (set! (-> *part-id-table* 4567 init-specs 6 initial-valuef) f30-0)
          (set! (-> *part-id-table* 4570 init-specs 5 initial-valuef) f28-0)
          (set! (-> *part-id-table* 4570 init-specs 6 initial-valuef) f30-0)
          (set! (-> *part-id-table* 4571 init-specs 5 initial-valuef) f28-0)
          (set! (-> *part-id-table* 4571 init-specs 6 initial-valuef) f30-0)
          )
        (cond
          ((zero? s1-0)
           (if s3-0
               (spawn-from-mat (-> this reticle) s5-0)
               )
           (let ((s1-1 (new 'stack-no-clear 'matrix)))
             (let* ((f0-2 (lerp-scale 1.0 0.1 (the float (mod s2-0 90)) 90.0 0.0))
                    (f30-1 (* 3686.4 f0-2))
                    )
               (let* ((a2-2 s1-1)
                      (a3-2 s5-0)
                      (v1-64 (-> a3-2 rvec quad))
                      (a0-9 (-> a3-2 uvec quad))
                      (a1-3 (-> a3-2 fvec quad))
                      (a3-3 (-> a3-2 trans quad))
                      )
                 (set! (-> a2-2 rvec quad) v1-64)
                 (set! (-> a2-2 uvec quad) a0-9)
                 (set! (-> a2-2 fvec quad) a1-3)
                 (set! (-> a2-2 trans quad) a3-3)
                 )
               (vector+float*! (-> s1-1 trans) (-> s5-0 trans) (-> s5-0 rvec) (- f30-1))
               (vector+float*! (-> s1-1 trans) (-> s1-1 trans) (-> s5-0 fvec) (- f30-1))
               (spawn-from-mat (-> this reticle-corner-0) s1-1)
               (vector+float*! (-> s1-1 trans) (-> s1-1 trans) (-> s5-0 rvec) (* 2.0 f30-1))
               (set! (-> s1-1 rvec quad) (-> s5-0 fvec quad))
               (vector-negate! (-> s1-1 fvec) (-> s5-0 rvec))
               (spawn-from-mat (-> this reticle-corner-1) s1-1)
               (vector+float*! (-> s1-1 trans) (-> s1-1 trans) (-> s5-0 fvec) (* 2.0 f30-1))
               (vector-negate! (-> s1-1 rvec) (-> s5-0 rvec))
               (vector-negate! (-> s1-1 fvec) (-> s5-0 fvec))
               (spawn-from-mat (-> this reticle-corner-2) s1-1)
               (vector+float*! (-> s1-1 trans) (-> s1-1 trans) (-> s5-0 rvec) (* -2.0 f30-1))
               )
             (vector-negate! (-> s1-1 rvec) (-> s5-0 fvec))
             (set! (-> s1-1 fvec quad) (-> s5-0 rvec quad))
             (spawn-from-mat (-> this reticle-corner-3) s1-1)
             )
           )
          ((= s1-0 2)
           (if s3-0
               (spawn-from-mat (-> this reticle-super) s5-0)
               )
           (if s0-0
               (spawn-from-mat (-> this reticle-super-ring) s5-0)
               )
           )
          (else
            (spawn-from-mat (-> this reticle-super-ring) s5-0)
            )
          )
        (if s3-0
            (spawn-from-mat (-> this reticle-dot) s5-0)
            )
        )
      (let ((a1-21 (new 'stack-no-clear 'vector)))
        (vector-! a1-21 (-> s5-0 trans) s4-0)
        (set! (-> a1-21 y) 0.0)
        (vector-normalize-copy! (-> s5-0 fvec) a1-21 1.8)
        )
      (vector-cross! (-> s5-0 rvec) (-> s5-0 uvec) (-> s5-0 fvec))
      (vector+float*! (-> s5-0 trans) (-> s5-0 trans) (-> s5-0 fvec) -4096.0)
      (spawn-from-mat (-> this reticle-arrow) s5-0)
      )
    )
  0
  (none)
  )

;; WARN: Return type mismatch sparticle-launch-control vs prec-mine-shooter-reticle-info.
(defmethod relocate ((this prec-mine-shooter-reticle-info) (offset int))
  (if (nonzero? (-> this reticle))
      (&+! (-> this reticle) offset)
      )
  (if (nonzero? (-> this reticle-corner-0))
      (&+! (-> this reticle-corner-0) offset)
      )
  (if (nonzero? (-> this reticle-corner-1))
      (&+! (-> this reticle-corner-1) offset)
      )
  (if (nonzero? (-> this reticle-corner-2))
      (&+! (-> this reticle-corner-2) offset)
      )
  (if (nonzero? (-> this reticle-corner-3))
      (&+! (-> this reticle-corner-3) offset)
      )
  (if (nonzero? (-> this reticle-dot))
      (&+! (-> this reticle-dot) offset)
      )
  (if (nonzero? (-> this reticle-arrow))
      (&+! (-> this reticle-arrow) offset)
      )
  (if (nonzero? (-> this reticle-super))
      (&+! (-> this reticle-super) offset)
      )
  (the-as prec-mine-shooter-reticle-info (when (nonzero? (-> this reticle-super-ring))
                                      (let ((v0-0 (&+ (-> this reticle-super-ring) offset)))
                                        (set! (-> this reticle-super-ring) v0-0)
                                        v0-0
                                        )
                                      )
          )
  )

(defmethod prec-mine-shooter-reticle-info-method-11 ((this prec-mine-shooter-reticle-info))
  (if (nonzero? (-> this reticle))
      (kill-particles (-> this reticle))
      )
  (if (nonzero? (-> this reticle-corner-0))
      (kill-particles (-> this reticle-corner-0))
      )
  (if (nonzero? (-> this reticle-corner-1))
      (kill-particles (-> this reticle-corner-1))
      )
  (if (nonzero? (-> this reticle-corner-2))
      (kill-particles (-> this reticle-corner-2))
      )
  (if (nonzero? (-> this reticle-corner-3))
      (kill-particles (-> this reticle-corner-3))
      )
  (if (nonzero? (-> this reticle-dot))
      (kill-particles (-> this reticle-dot))
      )
  (if (nonzero? (-> this reticle-arrow))
      (kill-particles (-> this reticle-arrow))
      )
  (if (nonzero? (-> this reticle-super))
      (kill-particles (-> this reticle-super))
      )
  (if (nonzero? (-> this reticle-super-ring))
      (kill-particles (-> this reticle-super-ring))
      )
  0
  (none)
  )

(deftype prec-mine-shooter-shot (projectile)
  ((trail-part             sparticle-launch-control)
   (traj                   trajectory  :inline)
   (traj-time              time-frame)
   (shot-dest              vector      :inline)
   (impact-played          symbol)
   (reticle-sound          sound-id)
   (reticle-sound-playing  symbol)
   )
  (:methods
    (stop-reticle-sound (_type_) none)
    )
  )

(defmethod stop-reticle-sound ((this prec-mine-shooter-shot))
  (when (-> this reticle-sound-playing)
    (sound-stop (-> this reticle-sound))
    (set! (-> this reticle-sound-playing) #f)
    )
  0
  (none)
  )

(defmethod relocate ((this prec-mine-shooter-shot) (offset int))
  (if (nonzero? (-> this trail-part))
      (&+! (-> this trail-part) offset)
      )
  (call-parent-method this offset)
  )

(defmethod deactivate ((this prec-mine-shooter-shot))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  (stop-reticle-sound this)
  (call-parent-method this)
  (none)
  )

(defmethod projectile-method-25 ((this prec-mine-shooter-shot))
  (if (nonzero? (-> this trail-part))
      (push-back (-> this trail-part) (-> this root trans))
      )
  0
  (none)
  )

(defmethod setup-collision! ((this prec-mine-shooter-shot))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-projectile)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((v1-6 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-6 prim-core collide-as) (collide-spec projectile))
      (set! (-> v1-6 prim-core collide-with)
            (collide-spec
              backgnd
              jak
              crate
              civilian
              enemy
              obstacle
              vehicle-sphere
              hit-by-others-list
              player-list
              pusher
              shield
              )
            )
      (set! (-> v1-6 prim-core action) (collide-action solid))
      (set-vector! (-> v1-6 local-sphere) 0.0 0.0 0.0 3072.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) v1-6)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-9 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-9 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-9 prim-core collide-with))
      )
    (set! (-> s5-0 max-iteration-count) (the-as uint 2))
    (set! (-> s5-0 event-self) 'touched)
    (set! (-> this root) s5-0)
    )
  (set! (-> this root pat-ignore-mask)
        (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noproj #x1 :noendlessfall #x1 :board #x1)
        )
  0
  (none)
  )

(defmethod init-proj-settings! ((this prec-mine-shooter-shot))
  (with-pp
    (set! (-> this attack-mode) 'eco-dark)
    (set! (-> this sound-id) (new-sound-id))
    (let ((t9-1 (method-of-type projectile init-proj-settings!)))
      (t9-1 this)
      )
    (set! (-> this shot-dest quad) (-> this root transv quad))
    (set-time! (-> this traj-time))
    pp
    (set! (-> this trail-part)
      (the-as
        sparticle-launch-control
        (new 'process 'sparticle-subsampler *sp-particle-system-2d* (-> *part-id-table* 4530) 10.0)
        )
      )
    (setup-from-to-duration-and-height! (-> this traj) (-> this root trans) (-> this root transv) 225.0 8192.0)
    (compute-transv-at-time (-> this traj) 0.0 (-> this root transv))
    (set! (-> this pre-move-transv quad) (-> this root transv quad))
    (vector-normalize-copy! (-> this starting-dir) (-> this root transv) 1.0)
    (vector+float*! (-> this base-target-pos) (-> this root trans) (-> this starting-dir) 2048000.0)
    (set! (-> this target-pos quad) (-> this base-target-pos quad))
    (set! (-> this impact-played) #f)
    (set! (-> this reticle-sound) (new-sound-id))
    ;(sound-play "reticle-lock" :id (-> this reticle-sound) :position (-> this shot-dest))
    ;(set! (-> this reticle-sound-playing) #t)
    0
    (none)
    )
  )

(defmethod play-impact-sound ((this prec-mine-shooter-shot) (arg0 projectile-options))
  (let ((v1-0 arg0))
    (cond
      ((zero? v1-0)
       )
      ((= v1-0 (projectile-options po0))
       (sound-play "cent-fire-bomb" :position (-> this root trans))
       )
      ((= v1-0 (projectile-options po0 po1))
       )
      )
    )
  (none)
  )

(defstate moving (prec-mine-shooter-shot)
  :virtual #t
  :trans (behavior ()
    (local-vars (at-0 int))
    (rlet ((vf0 :class vf)
           (vf1 :class vf)
           (vf2 :class vf)
           )
      (init-vf0-vector)
      (add-debug-sphere #t (bucket-id debug-no-zbuf1) (-> self shot-dest) (meters 1) *color-red*)
      (cond
        ((time-elapsed? (-> self traj-time) (the int (-> self traj time)))
         (go-virtual impact)
         )
        ((and (not (-> self impact-played))
              (time-elapsed? (+ (-> self traj-time) (seconds -0.5)) (the int (-> self traj time)))
              )
         (sound-play "erol-proj-incom" :position (-> self root trans))
         (set! (-> self impact-played) #t)
         )
        )
      (let ((gp-1 (new 'stack-no-clear 'vector)))
        (compute-trans-at-time
          (-> self traj)
          (fmin (-> self traj time) (the float (- (current-time) (-> self traj-time))))
          gp-1
          )
        (vector-! (-> self pre-move-transv) gp-1 (-> self root trans))
        (let ((v1-22 (-> self pre-move-transv)))
          (.lvf vf1 (&-> (-> self pre-move-transv) quad))
          (let ((f0-6 (-> self clock frames-per-second)))
            (.mov at-0 f0-6)
            )
          (.mov vf2 at-0)
          (.mov.vf vf1 vf0 :mask #b1000)
          (.mul.x.vf vf1 vf1 vf2 :mask #b111)
          (.svf (&-> v1-22 quad) vf1)
          )
        (set! (-> self root transv quad) (-> self pre-move-transv quad))
        (if (< 2191360.0 (-> gp-1 y))
            (integrate-and-collide! (-> self root) (-> self root transv))
            (projectile-move-fill-line-sphere self)
            )
        )
      (if (logtest? (collide-status
                      on-surface
                      on-ground
                      touch-surface
                      touch-wall
                      touch-ceiling
                      touch-actor
                      on-special-surface
                      touch-edge
                      no-touch
                      blocked
                      on-water
                      impact-surface
                      touch-background
                      stuck
                      touch-ceiling-sticky
                      glance
                      probe-hit
                      )
                    (-> self root status)
                    )
          (go-impact! self)
          )
      ;(send-event (ppointer->process (-> self parent)) 'draw-reticle (-> self shot-dest) (-> self traj) 0)
      )
    )
  )

(defstate impact (prec-mine-shooter-shot)
  :virtual #t
  :enter (behavior ()
    (stop-reticle-sound self)
    (sound-play "erol-proj-expl" :position (-> self root trans))
    (let ((v1-5 (-> self root root-prim)))
      (set! (-> v1-5 prim-core collide-as) (collide-spec))
      (set! (-> v1-5 prim-core collide-with) (collide-spec))
      )
    0
    (let ((gp-1 (new 'stack-no-clear 'explosion-init-params)))
      (set! (-> gp-1 spawn-point quad) (-> self root trans quad))
      (quaternion-identity! (-> gp-1 spawn-quat))
      (set! (-> gp-1 radius) 8192.0)
      (set! (-> gp-1 scale) 1.0)
      (set! (-> gp-1 group) (-> *part-group-id-table* 1360))
      (set! (-> gp-1 collide-with)
            (collide-spec backgnd jak crate enemy obstacle vehicle-sphere hit-by-others-list player-list pusher shield)
            )
      (set! (-> gp-1 damage) 2.0)
      (set! (-> gp-1 damage-scale) 1.0)
      (set! (-> gp-1 vehicle-damage-factor) 1.0)
      (set! (-> gp-1 vehicle-impulse-factor) 1.0)
      (set! (-> gp-1 ignore-proc) (process->handle #f))
      (explosion-spawn gp-1 (ppointer->process (-> self parent)))
      )
    (send-event (ppointer->process (-> self parent)) 'shot-hit (-> self root trans))
    (set-time! (-> self state-time))
    )
  :trans (behavior ()
    (when (and (time-elapsed? (-> self state-time) (seconds 10)) (not (-> self child)))
      (deactivate self)
      (go empty-state)
      )
    )
  :code sleep-code
  )

(defskelgroup skel-terraformer-mine terraformer-mine terraformer-mine-lod0-jg terraformer-mine-idle-ja
              ((terraformer-mine-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 4)
              )

(deftype prec-mine-shooter (process-drawable)
  ((center      vector  :inline)
   (shot-timer  time-frame)
   (shots-left  int32)
   (dest-quat   quaternion  :inline)
   (can-shoot?  symbol)
   (exploded    symbol)
   (reticle-info       prec-mine-shooter-reticle-info  :inline)
   (launching-group    sparticle-launch-group)
   (reticle-sound          sound-id)
   (reticle-sound-playing  symbol)
   )
  (:state-methods
    idle
    die
    )
  (:methods
    (prec-mine-shooter-target-pos (_type_ vector int) vector)
    (fire-shot! (_type_) none)
    (prec-mine-shooter-method-11 (_type_ float vector) none)
    (prec-mine-shooter-method-21 (_type_ float vector) none)
    )
  )

(defmethod relocate ((this prec-mine-shooter) (offset int))
  (relocate (-> this reticle-info) offset)
  (call-parent-method this offset)
  )

(defmethod deactivate ((this prec-mine-shooter))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  (prec-mine-shooter-reticle-info-method-11 (-> this reticle-info))
  ;(factory-boss-method-30 this)
  (call-parent-method this)
  (none)
  )

(defbehavior prec-mine-shooter-explode prec-mine-shooter ()
  (let ((gp-0 (new 'stack-no-clear 'explosion-init-params)))
    (sound-play "mine-explode" :position (-> self root trans))
    (set! (-> gp-0 spawn-point quad) (-> self root trans quad))
    (quaternion-identity! (-> gp-0 spawn-quat))
    (set! (-> gp-0 radius) 24576.0)
    (set! (-> gp-0 scale) 1.0)
    (set! (-> gp-0 group) (-> *part-group-id-table* 218))
    (set! (-> gp-0 collide-with) (collide-spec))
    (set! (-> gp-0 damage) 2.0)
    (set! (-> gp-0 damage-scale) 1.0)
    (set! (-> gp-0 vehicle-damage-factor) 1.0)
    (set! (-> gp-0 vehicle-impulse-factor) 1.0)
    (set! (-> gp-0 ignore-proc) (process->handle #f))
    (explosion-spawn gp-0 (the-as process-drawable *default-pool*))
    )
  (set! (-> self exploded) #t)
  )

;; definition for method 21 of type prec-mine-shooter
;; INFO: Used lq/sq
;; WARN: Return type mismatch vector vs none.
(defmethod prec-mine-shooter-method-11 ((this prec-mine-shooter) (arg0 float) (arg1 vector))
  (set! (-> arg1 quad) (-> this center quad))
  (+! (-> arg1 y) 4096.0)
  (let ((v1-2 arg0))
    (cond
      ((zero? v1-2)
       (+! (-> arg1 x) 98304.0)
       (+! (-> arg1 z) 98304.0)
       )
      ((= (the-as int v1-2) 1)
       (+! (-> arg1 x) 98304.0)
       (+! (-> arg1 z) -98304.0)
       )
      ((= (the-as int v1-2) 2)
       (+! (-> arg1 x) -98304.0)
       (+! (-> arg1 z) -98304.0)
       )
      (else
        (+! (-> arg1 x) -98304.0)
        (+! (-> arg1 z) 98304.0)
        )
      )
    )
  (none)
  )

(defmethod prec-mine-shooter-target-pos ((this prec-mine-shooter) (arg0 vector) (arg1 int))
  (set! (-> arg0 quad) (-> (target-pos 0) quad))
  (set! (-> arg0 y) (-> this center y))
  (when (= arg1 1)
    (let ((a0-3 (- (the-as int (- (current-time) (-> this shot-timer)))))
          (v1-7 (vector-reset! (new 'stack-no-clear 'vector)))
          )
      (set! (-> v1-7 y) (-> this center y))
      (vector-! arg0 arg0 v1-7)
      (vector+float*! arg0 v1-7 arg0 (fmax 0.0 (fmin 1.0 (* 0.008888889 (the float a0-3)))))
      )
    )
  arg0
  )

(defmethod fire-shot! ((this prec-mine-shooter))
  (let ((gp-0 (new 'stack-no-clear 'projectile-init-by-other-params))
        (s5-0 (>= (- (current-time) (+ (-> this shot-timer) (seconds -0.75))) 0))
        )
    (let ((s3-0 (new 'stack-no-clear 'vector))
          (s4-0 (new 'stack-no-clear 'vector))
          )
      (vector<-cspace! s3-0 (-> this node-list data 5)) ;; "main" joint-node
      (prec-mine-shooter-target-pos this s4-0 1)
      (set! (-> gp-0 ent) (-> this entity))
      (set! (-> gp-0 charge) 1.0)
      (set! (-> gp-0 options) (projectile-options))
      (logclear! (-> gp-0 options) (projectile-options po14 po15 po16))
      (set! (-> gp-0 pos quad) (-> s3-0 quad))
      (set! (-> gp-0 vel quad) (-> s4-0 quad))
      )
    (set! (-> gp-0 notify-handle) (the-as handle #f))
    (set! (-> gp-0 owner-handle) (the-as handle #f))
    (set! (-> gp-0 target-handle) (the-as handle #f))
    (set! (-> gp-0 target-pos quad) (the-as uint128 0))
    (set! (-> gp-0 ignore-handle) (process->handle this))
    (let* ((v1-11 *game-info*)
           (a0-11 (+ (-> v1-11 attack-id) 1))
           )
      (set! (-> v1-11 attack-id) a0-11)
      (set! (-> gp-0 attack-id) a0-11)
      )
    (set! (-> gp-0 timeout) (seconds 4))
    (+! (-> this shots-left) -1)
    (spawn-projectile prec-mine-shooter-shot gp-0 this *default-dead-pool*)
    )
    (none)
  )

(defbehavior prec-mine-shooter-handler prec-mine-shooter ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('touch 'touched 'attack 'bonk 'explode)
      (let* ((_proc arg0)
              (focus-proc (if (type? _proc process-focusable)
                              (the-as process-focusable _proc)
                              )
                          )
              )
         (when focus-proc
           (let ((a0-4
                   (vector-normalize!
                     (vector-! (new 'stack-no-clear 'vector) (-> focus-proc root trans) (-> self root trans))
                     1.0
                     )
                   )
                 )
             (send-event
               focus-proc
               'attack-or-shove
               (-> arg3 param 0)
               (static-attack-info ((id (new-attack-id))
                                    (vector a0-4)
                                    (shove-back (meters 5))
                                    (shove-up (meters 3))
                                    (control (if (focus-test? focus-proc board)
                                                 1.0
                                                 0.0
                                                 )
                                             )
                                    )
                                   )
               )
             )
           )
         )
     (if (and (not (-> self exploded)) (type? arg0 projectile))
         (turbo-pickup-spawn (-> self root trans))
         )
     (prec-mine-shooter-explode)
     )
    (('draw-reticle)
     (prec-mine-shooter-reticle-info-method-10
       (-> self reticle-info)
       (the-as vector (-> arg3 param 0))
       (the-as vector (-> arg3 param 1))
       0
       (the-as int (-> arg3 param 2))
       )
     )
    )
  )

(defstate idle (prec-mine-shooter)
  :virtual #t
  :event prec-mine-shooter-handler
  :enter (behavior ()
    (set-time! (-> self shot-timer))
    (set! (-> self shots-left) 4)
    (set! (-> self shot-timer) (+ (current-time) (seconds 3)))
    )
  :trans (behavior ()
    (let ((v1-2 (ja-group)))
      (cond
        ((and v1-2 (= v1-2 terraformer-mine-idle-ja))
         (ja :num! (loop!))
         )
        (else
          (ja :num! (seek!))
          (if (ja-done? 0)
              (ja :group! terraformer-mine-idle-ja :num! min)
              )
          )
        )
      )
    (when (= (-> self can-shoot?) #t)
      (set! (-> self can-shoot?) #f)
      (set! (-> self shot-timer) (+ (current-time) (the int (* 300.0 (rand-vu-float-range 2.0 4.0)))))
      (fire-shot! self)
      )
    (when (and (time-elapsed? (-> self shot-timer) (seconds 0.6)) (= (-> self can-shoot?) #f))
      (set! (-> self can-shoot?) #t)
      )
    (when (= (-> self exploded) #t)
      (go-virtual die)
      )
    )
  :code sleep-code
  :post ja-post
  )

(defstate die (prec-mine-shooter)
  :virtual #t
  :code (behavior ()
    (cleanup-for-death self)
    (deactivate self)
    )
  )

;; definition for method 11 of type prec-mine-shooter
;; INFO: Used lq/sq
(defmethod init-from-entity! ((this prec-mine-shooter) (arg0 entity-actor))
 (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (let ((v1-2 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
      (set! (-> v1-2 prim-core collide-as) (collide-spec enemy))
      (set! (-> v1-2 prim-core collide-with) (collide-spec jak bot hit-by-others-list player-list))
      (set! (-> v1-2 prim-core action) (collide-action solid))
      (set! (-> v1-2 transform-index) 3)
      (set-vector! (-> v1-2 local-sphere) 0.0 0.0 0.0 16384.0)
      (set! (-> s4-0 total-prims) (the-as uint 1))
      (set! (-> s4-0 root-prim) v1-2)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-5 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-5 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-5 prim-core collide-with))
      )
    (set! (-> s4-0 event-self) 'touched)
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-terraformer-mine" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  ;(init! (-> this reticle-info) this)
  (set! (-> this center quad) (-> this root trans quad))
  (+! (-> this center z) 83968.0)
  (+! (-> this center y) -65536.0)
  (+! (-> this center x) -83968.0)
  (set! (-> this can-shoot?) #f)
  (set! (-> this reticle-sound) (new-sound-id))
  (set! (-> this reticle-sound-playing) #f)
  (quaternion-copy! (-> this dest-quat) (-> this root quat))
  (logior! (-> this mask) (process-mask enemy))
  (logclear! (-> this mask) (process-mask actor-pause))
  (go (method-of-object this idle))
  )

#|
;; definition of type hud-prec-mine-shooter
(deftype hud-prec-mine-shooter (hud)
  ()
  )

;; definition for method 3 of type hud-prec-mine-shooter
(defmethod inspect ((this hud-prec-mine-shooter))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type hud inspect)))
    (t9-0 this)
    )
  (label cfg-4)
  this
  )

;; definition for method 15 of type hud-prec-mine-shooter
;; WARN: Return type mismatch int vs none.
(defmethod draw ((this hud-prec-mine-shooter))
  (set-hud-piece-position!
    (the-as hud-sprite (&-> this sprites 3 flags))
    (the int (+ 472.0 (* 130.0 (-> this offset))))
    130
    )
  (format (clear (-> this strings 0 text)) "press triangle to complete factory boss")
  (set-hud-piece-position!
    (the-as hud-sprite (&-> this strings 0 pos w))
    (the int (+ 472.0 (* 130.0 (-> this offset))))
    130
    )
  ((method-of-type hud draw) this)
  0
  (none)
  )

;; definition for method 17 of type hud-prec-mine-shooter
;; WARN: Return type mismatch int vs none.
;; ERROR: Failed store: (s.w! (+ this 2972) v1-3) at op 19
(defmethod init-callback ((this hud-prec-mine-shooter))
  (set! (-> this level) (level-get *level* 'factoryd))
  (let ((v1-3
          (add-process *gui-control* this (gui-channel hud-middle-right) (gui-action hidden) (-> this name) 81920.0 0)
          )
        )
    (s.w! (+ this 2972) v1-3)
    )
  (logior! (-> this flags) (hud-flags show))
  (alloc-string-if-needed this 0)
  (set! (-> this strings 0 scale) 0.6)
  (set! (-> this strings 0 flags) (font-flags shadow kerning right large))
  0
  (none)
  )

;; definition of type task-manager-prec-mine-shooter
(deftype task-manager-prec-mine-shooter (task-manager)
  ((button-up  symbol  :overlay-at intro-time)
   )
  )

;; definition for method 3 of type task-manager-prec-mine-shooter
(defmethod inspect ((this task-manager-prec-mine-shooter))
  (when (not this)
    (set! this this)
    (goto cfg-4)
    )
  (let ((t9-0 (method-of-type task-manager inspect)))
    (t9-0 this)
    )
  (format #t "~2Tbutton-up: ~A~%" (-> this button-up))
  (label cfg-4)
  this
  )

;; definition for method 26 of type task-manager-prec-mine-shooter
;; WARN: Return type mismatch object vs none.
(defmethod task-manager-method-26 ((this task-manager-prec-mine-shooter))
  (let ((t9-0 (method-of-type task-manager task-manager-method-26)))
    (t9-0 this)
    )
  (if (not (cpad-hold? 0 triangle))
      (set! (-> this button-up) #t)
      )
  (if (and (-> this button-up) (cpad-hold? 0 triangle))
      (send-event this 'complete)
      )
  (none)
  )

;; definition for method 25 of type task-manager-prec-mine-shooter
;; WARN: Return type mismatch object vs none.
(defmethod task-manager-method-25 ((this task-manager-prec-mine-shooter))
  (let ((t9-0 (method-of-type task-manager task-manager-method-25)))
    (t9-0 this)
    )
  (send-event (handle->process (-> this hud-timer)) 'hide-and-die)
  (none)
  )

;; definition for method 21 of type task-manager-prec-mine-shooter
;; WARN: Return type mismatch symbol vs none.
(defmethod set-time-limit ((this task-manager-prec-mine-shooter))
  (let ((t9-0 (method-of-type task-manager set-time-limit)))
    (t9-0 this)
    )
  (set! (-> this hud-timer)
        (ppointer->handle (process-spawn hud-prec-mine-shooter :init hud-init-by-other :name "hud-prec-mine-shooter" :to this))
        )
  (set! (-> this button-up) #f)
  (none)
  )




